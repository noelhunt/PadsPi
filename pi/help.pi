static const char *helptext[] = {
"1.  Introduction",
"",
"Welcome to the pi debugger!  Pi(Process Inspector) is a window-based interactive",
"debugger for C, C++, and assembler programs.  It provides a network of windows",
"for each program it controls, allowing programs to be examined from different",
"perspectives.  Pi can attach to running programs, debug multiple processes",
"concurrently, and monitor the values of C expressions on-the-fly, with only",
"minor impact on the timing of a running program.",
"",
"This Help window provides detailed descriptions of pi's user interface, window",
"types, window layout, and mouse and keyboard operators.  New users should read",
"the \"OpenLook Interface\" and \"Window Types\" sections first, and then the window",
"descriptions, as needed.  Topics of interest may be displayed several ways:",
"",
"  1.  For the description of a window and its operators, select entries in the",
"      \"help\" sub-menu that is available in the \"edit\" menu in every window's",
"      menu bar.",
"",
"  2.  Select text in any window (except the Keyboard Input window) and type the",
"      character \"?\" followed by a carriage return.  This scrolls the Help window",
"      to the description of the current keyboard language.",
"",
"  3.  Select entries in the \"topics\" pop-up window that is available in the Help",
"      window's menu bar.",
"",
"1.1  Starting Pi",
"",
"To start pi, place the directory where it is installed on your PATH and type:",
"",
"     pi &",
"",
"On start-up, pi starts pads, its companion user interface process, and creates",
"two windows on the screen: the Unix Pi window and the Keyboard Input window.",
"These windows are described in the \"Unix Pi Window\" and \"Keyboard Input Window\"",
"sections.  The default window layouts, fonts, and colors are determined by X",
"resources (see \"X Resources\").",
"",
"1.2  Pads",
"",
"Pi is implemented with two processes, pi and pads, that are connected to each",
"other with a bidirectional pipe (Unix domain socket).  Pads is a C program that",
"provides the user interface and manages the display, keyboard and mouse.  Pi,",
"the debugger, is a C++ program that does everything else: it controls processes",
"using the debug primitives provide by the Unix operating system, manages the",
"symbol table and source files, and executes the operators selected in the menus",
"or entered from the keyboard.  The user interface is separated from the debugger",
"for several reasons:",
"",
"  1.  Pads can be customized to run in different windowing environments without",
"      having to modify the debugger.",
"",
"  2.  Pads is responsive to user requests, such as popping up menus, even when",
"      pi is busy performing complex operations.",
"",
"  3.  Pi and pads may execute on different machines.  When debugging remotely,",
"      the network traffic between pi and pads is much less than the network",
"      traffic between pads and the X server.  In addition, pads may be used to",
"      to debug programs remotely with window systems that do not support network",
"      connections.",
"",
"1.3  Remote Execution",
"",
"You have two options for running the OpenLook version of pi on a remote machine.",
"",
"  1.  Run both pi and pads on the remote machine and use X's networking",
"      facilities to connect to the local display.  On the local machine enable X",
"      connections from the remote system with the xhost command, and on the",
"      remote system set the X11 environment variable DISPLAY to the name of the",
"      local display before pi is started.  For example, if the hostname of the",
"      workstation running the X server is daksun and the remote machine's",
"      hostname is integral:",
"",
"           daksun% xhost +integral",
"           integral being added to access control list",
"           daksun% rlogin integral",
"           integral% DISPLAY=daksun:0",
"           integral% export DISPLAY",
"           integral% pi &",
"",
"  2.  Run pads locally and pi on the remote machine.  This will result in much",
"      less Ethernet traffic.  To do this, the directory containing the pi binary",
"      on the remote system should be set in the JTOOLSBIN environment variable,",
"      and pi should be invoked with the -r option on the local machine.  For",
"      example, if the pi binary resides in the directory /usr/local/bin on the",
"      remote machine named integral:",
"",
"           daksun% JTOOLSBIN=/usr/local/bin",
"           daksun% export JTOOLSBIN",
"           daksun% pi -r integral &",
"",
"      If the JTOOLSBIN environment variable is not set pi assumes that the pi",
"      binary resides in the directory /usr/jtools/bin on the remote system.",
"",
"1.4  Stack Trace",
"",
"Pi may be used to print a stack trace of a core dump on the standard output with",
"the command:",
"",
"     pi -t core_file symbol_table_file",
"",
"The symbol table file should be the name of the executable file that generated",
"the core dump.  Starting at the call to main, pi will print the symbolic",
"location of the program counter, and the values of arguments and local variables",
"for every function that was active when the error occurred.  When started with",
"the -t option, pi does not use the window system or start pads.",
"",
"1.5  Compiling",
"",
"Programs that are going to be debugged with pi should be compiled with the -g",
"option.  If Sun's unbundled compiler is used with SunOS 5.0 (Solaris 2.0) or",
"later on SPARCs, the -xs option should also be used.  These place additional",
"symbol table information for debugging purposes in the executable file, such as",
"mappings between C statements and assembly instructions, detailed descriptions",
"of user defined types, as well as type and location information for functions,",
"local and global variables, and arguments.  Only files compiled with -g will",
"appear in the Source Files window for a process.  On most machines, the -g",
"option is incompatible with the -O option, so it will not be possible to debug",
"symbolically files compiled with the optimizer at the source code level.",
"",
"1.6  C++ Code",
"",
"Pi is a good tool for debugging C++ code, but only supports a few C++ specific",
"features:",
"",
"  1.  It has a built-in C++ name de-mangler to convert the complex variable",
"      names generated by cfront back into their original names.  The de-mangler",
"      is compatible with version 3.0 of USL C++.",
"",
"  2.  Source Text windows generate special menus when several functions are",
"      generated by a single line of source code.  These menus allow the",
"      functions to be treated individually or as a group.  Code generated by C++",
"      templates and C++ in-line functions that are not coded in-line use these",
"      facilities.",
"",
"  3.  The \"func index\" menu in Source Text windows lists the argument prototypes",
"      for C++ functions, to allow overloaded function names to be distinguished.",
"",
"  4.  Pi's expression interpreter allows the character sequence \"::\" to be",
"      embedded in identifiers.",
"",
"Pi does not have a C++ expression interpreter, and treats C++ code as C.  Even",
"though cfront generates C structs that may be different from the C++ classes you",
"write, pi's tools for browsing through C data structures allow you to find the",
"correspondence between the C++ and generated C with a minimal amount of effort.",
"While a C++ expression interpreter would improve things, pi does a reasonable",
"job treating C++ code as C.",
"",
"1.7  Distribution",
"",
"This version of pi is proprietary to AT&T, and should not be distributed outside",
"the company without permission from Department BL0112280.  Within AT&T, it may",
"be redistributed freely.",
"",
"I maintain a mailing list of users for updates and propaganda.  If you would",
"like to be added, send electronic or paper mail to:",
"",
"             David Kapilow",
"             AT&T Bell Laboratories",
"             Room 2C-479",
"             600 Mountain Ave",
"             P. O. Box 636",
"             Murray Hill, N. J. 07974-0636",
"     Phone:  (908)-582-3596",
"     Email:  research!dak or dak@research.att.com",
"",
"The mail should state whether you would like to receive future binary",
"distributions, or just email descriptions of the new features.  Bug reports,",
"complaints, compliments, and suggestions are also welcome.",
"",
"",
"2.  OPENLOOK Interface",
"",
"This section describes the window layout, use of the mouse and keyboard, and",
"interactions with the window manager for the version of pi that uses the",
"OPENLOOK toolkit.  The toolkit runs on top of the X Window System and uses the",
"window manager and resource values to place and layout the windows.  Pi works",
"best with the OPENLOOK window manager (olwm) since the toolkit sets properties",
"that are unique to it, but other window managers may also be used.",
"",
"Pi's user interface distinguishes it from most other debuggers.  Instead of",
"providing a centralized command language and a static set of menus, pi's menus",
"and keyboard languages dynamically depend on the window, selected text within",
"that window, and the state of the program.  For example, the menu for a line in",
"a source code window initially lets you set several types of breakpoints on that",
"line.  Once a breakpoint is set, however, the menu entries for setting",
"breakpoints are replaced with an entry for removing the breakpoint.",
"",
"Customizing the menus to the current selection provides a powerful user",
"interface.  Instead of having to decide which of the available operators are",
"applicable, the system does it for you.  You may always determine what",
"operations are possible from a line by selecting it and looking at its menu.",
"",
"Customizing the keyboard interface to the selection allows simple input",
"sequences to invoke complex operators that would not be possible with a",
"centralized interpreter.  For example, the input language of a Frame window, a",
"window used to examine C expressions, accepts C expressions.  There are no",
"difficult to remember commands that must be typed in addition to the",
"expressions.  Furthermore, the keyboard language for a line displaying a complex",
"expression in a Frame window allows that expression to be reused in deriving new",
"expressions with a single keystroke.",
"",
"2.1  Mouse Buttons",
"",
"By default, the mouse buttons have the following bindings in OPENLOOK:",
"",
"     Button  Operator        Use",
"     ------  --------        ---------------------------------------------",
"     Left    SELECT          select text, default menu selections, buttons",
"     Middle  ADJUST          adjust the text selection",
"     Right   MENU            generate menus",
"",
"These may be changed by setting resources in your .Xdefaults file.  For",
"instance, the lines:",
"",
"     *selectBtn:     <Button3>",
"     *menuBtn:       <Button1>",
"",
"may be used to swap the SELECT and MENU buttons.",
"",
"2.2  Window Manager",
"",
"Most X window managers surround windows with a title bars and borders, and",
"provide decorations for changing window layouts.  With olwm, pressing the MENU",
"button in the border or title bar generates a \"Window\" menu that allows that",
"window to be closed, moved, reshaped, or hidden.  Pressing SELECT in the title",
"bar or border fully exposes the window.  Pressing SELECT or ADJUST over the",
"push-pin in the title bar pulls the the pin out of the hole and closes the",
"window.",
"",
"Pi may turned into an icon by closing the Keyboard Input window.  With olwm,",
"this window may be closed by pressing SELECT on the title bar's abbreviated menu",
"button, or selecting \"Close\" in the \"Window\" menu generated in either the title",
"bar or border.  When the icon is opened, all of pi's windows are restored on the",
"screen.",
"",
"With other window managers, see the window manager's manual pages for a",
"description of the window decorations and menus.",
"",
"2.3  Window Layout",
"",
"A pi window contains a menu bar across the top of the window and a text region.",
"Horizontal and vertical scroll bars surround the text if the window is too small",
"to display it all.",
"",
"2.3.1  Menu Bars",
"The menu bar at the top of a window allows operators to be invoked from buttons,",
"menu buttons, and pop-up windows containing scrolling lists.",
"",
"Buttons are ovals with text in them, and are activated by moving the cursor over",
"the button and clicking SELECT.",
"",
"Menu buttons look like buttons, but have a down-pointing arrow after the text.",
"Pressing MENU with the cursor on top of the menu button pops up the menu.  To",
"invoke an operator, move the cursor over its menu entry and release the MENU",
"button.  If first menu entry is a push pin, placing the pin in the hole causes",
"the menu to be remain on the screen after the MENU button is released - it",
"becomes \"pinned\".",
"",
"Pinned menus are useful for repetitive operations, such as statement stepping,",
"and may be moved on the screen with the window manager.  To invoke operators in",
"a pinned menu, move the cursor over the desired entry and click SELECT or MENU.",
"Clicking multiple times invokes the operator multiple times.  With olwm, pinned",
"menus may be popped down by taking the pin out of the hole in the menu's title",
"bar with the SELECT button. If a pinned menu becomes hidden by another window,",
"clicking the MENU button on top of its menu button raises it to the top of the",
"window hierarchy.",
"",
"Pressing SELECT over a menu button invokes the default menu entry.  For most pi",
"menus, this puts the menu's push pin into the hole and pins the menu on the",
"screen.",
"",
"Scrolling lists are used when there are more than 13 entries in a menu.  In the",
"menu bar they look like buttons, but the text is followed by \"...\"  to indicate",
"a window will pop up.  To pop up the scrolling list, move the cursor over the",
"button and click SELECT.  With olwm, the scrolling list may be popped down by",
"pulling the push pin out of the hole with SELECT.  To select entries in the",
"scrolling list, use the scroll bar to display the desired entry, move the cursor",
"over it, and click SELECT.  If a scrolling list is hidden by another window,",
"clicking SELECT on its button in the menu bar raises it.",
"",
"2.3.2  Edit Menu",
"Every menu bar has an \"edit\" menu button with the following operators:",
"",
" send     Send the text selected in the window to the Keyboard Input window.",
"          This is an accelerator for selecting \"copy\", moving to the Keyboard",
"          Input window and selecting \"paste\" in its Edit menu.  This is the",
"          default menu entry, so selected text can be sent to the Keyboard",
"          window by simply clicking SELECT on the \"edit\" menu button.",
"",
" cut      Remove the selected lines from the window.  Partially selected lines",
"          are treated as if the whole line is selected.  Some windows, such as",
"          the Source Text window, do not allow lines to be removed from the",
"          window.",
"",
" clear    Equivalent to applying \"cut\" to every line in the window.  This entry",
"          is used to clean up.",
"",
" copy     Copy the selected text into the window system cut buffer.",
"",
" close    Remove the window from the screen.  If you are using olwm, you may",
"          alternatively pull the push pin out of the hole with the SELECT",
"          button, or choose \"dismiss\" in the menu generated by the MENU button",
"          in the window's title bar or border.",
"",
"          Closing a window may have side effects in the debugger. For example,",
"          closing a Process window closes all windows associated with that",
"          process and detaches the debugger from the process.",
"",
" help     Entries in this sub-menu open the Help window and scroll to the",
"          sections that describe the window and its operators.  The menu may",
"          have \"overview\", \"menu bar\", \"keyboard\", \"line menus\", and \"line",
"          keyboard\" entries.",
"",
"2.3.3  Line Menus",
"In the text region of a window the MENU button generates a menu, called the line",
"menu, that depends on the line containing the start of the currently selected",
"text.  Each line may generate a unique line menu.  For example, a line of source",
"code in a Source Text window generates a menu that allows breakpoints to be set,",
"the source to be disassembled, or the function's Frame window to be opened.",
"",
"If the line menu contains less than 13 entries a pop-up menu is generated.",
"Cascading menus, indicated by menu entries with right-pointing arrows on the",
"right side, are used to group common operators in sub-menus.  Pi menus only",
"cascade one level.",
"",
"When the line menu has more than 13 entires a scrolling list pop-up window is",
"generated and remains on the screen when the MENU button is released.  The",
"SELECT button invokes operators in the scrolling list.  The scrolling list is",
"popped down when any other line menu is generated.  With olwm, it may also be",
"popped down by pulling out the push pin in the title bar.",
"",
"2.4  Keyboard Input Window",
"",
"The Keyboard Input window is used to edit and send keyboard input to the",
"selected line or window.  Closing this window turns the whole application into",
"an icon.",
"",
"The Keyboard Input window's control area has a \"windows\" menu that allows you to",
"access all the windows.  Selecting an entry opens that windows, or exposes it if",
"it is already open.  The control area also has \"Window\" and \"Line\" fields that",
"display the window and line with the current keyboard focus.  The \"Line\" field",
"displays the line number, or \"None\" if the selected line does not accept",
"keyboard input.  The keyboard focus is set by moving the mouse into the text",
"region of a window and typing any key or using the SELECT or ADJUST buttons to",
"select text.  If a selection spans multiple lines, the keyboard focus is set to",
"the line containing the beginning of the selection.",
"",
"Text may be entered several ways:",
"",
"  1.  Type into any pi window.  The characters are echoed in the Keyboard Input",
"      window.  The backspace key may be used to delete the previous character.",
"",
"  2.  Use the \"send\" entry in the \"edit\" menu available in any window's menu bar",
"      to copy that windows selected text into the Keyboard Input window's",
"      insertion point.",
"",
"  3.  Type directly into the Keyboard Input window.",
"",
"  4.  Use the \"edit\" menu in Keyboard Input window, generated by the MENU button",
"      in the text region, to paste in text from other windows.",
"",
"The text is sent to the selected line or window when a carriage return is",
"appended to the end of Keyboard Input window, so the keyboard focus is only",
"important when the carriage return is entered.  This allows complicated",
"expressions to be grabbed from one window and sent to a second window's keyboard",
"interpreter.  Just move the cursor into the second window before typing the",
"carriage return.",
"",
"If all the lines in a window accept keyboard input, it is still possible to send",
"keyboard input to the window's keyboard interpreter by selecting the window's",
"last line.  A dummy blank line is inserted at the bottom of each window for this",
"purpose.",
"",
"The following input strings have special meanings:",
"",
" ?             Open the Help window and scroll to the section describing the",
"               keyboard language of the selected line or window.",
"",
" <shell_cmd    Run the shell command and use its standard output as the keyboard",
"               input.",
"",
" >shell_cmd    Runs the shell command using the selected line or window as",
"               standard input.",
"",
"For example, if no line is selected the string",
"",
"     >cat > outfile",
"",
"dumps the contents of the selected window into the file outfile while",
"",
"     < cat infile",
"",
"uses the contents of infile as keyboard input.",
"",
"2.5  X Resources",
"",
"Pi uses X11 fallback resources to set the default size and positions of the",
"windows, as well as other parameters.  The default values for Suns, SGIs, and",
"PCs are shown below.  They may be overridden by placing entries in your personal",
"resource database (usually $HOME/.Xdefaults), or by installing a resource",
"defaults file named Pads in the X11 app-defaults directory.",
"",
"X Resource                      Sun (1152x900)  SGI (1280x1024) PC (800x600)",
"-----------------------------   --------------- --------------- -------------",
"assembler.geometry:             275x400+673+445 275x400+683+495 235x250-7+330",
"breakpoint.geometry:            150x175+980+225 170x175+1000+26 235x250-7+330",
"frame.geometry:                 350x175+460+225 350x175+460+265 325x110-7+180",
"globals.geometry:               350x175+460+225 350x175+460+265 325x110-7+180",
"journal.geometry:               500x160+480+20  500x160+480+50  235x250-7+330",
"keyboard.geometry:              400x125+40+65   400x125+40+95   325x110-7+31",
"memory.geometry:                200x200+940+667 200x200+960+727 235x250-7+330",
"pi.geometry:                    500x160+460+30  500x160+460+60  425x110+18+31",
"process.geometry:               400x175+40+225  400x175+40+265  425x110+8+31",
"rtconnect.geometry:             500x160+480+20  500x160+480+50  425x110+8+31",
"rtpi.geometry:                  500x160+460+30  500x160+460+60  425x110+18+31",
"signals.geometry:               200x200+940+435 200x200+960+485 235x250-7+330",
"source.geometry:                600x400+40+435  600x400+40+485  435x395+8+180",
"srcfiles.geometry:              140x175+825+225 140x175+835+265 235x250-7+330",
"usertypes.geometry:             275x400+653+435 275x400+663+485 235x250-7+330",
"help*charsVisible:              83              83              84",
"help*linesVisible:              50              50              38",
"wd*linesVisible:                4               4               4",
"*blinkRate:                     0               0               0",
"TopLevelShell*Background:       grey80          grey70          grey",
"TopLevelShell*TextBackground:   white           midnight blue   orange",
"TopLevelShell*Caption.font:     lucidasans-bold screen13        fixed",
"TopLevelShell*font:        lucidasanstypewriter screen-bold13   fixed",
"",
"The following resources are only set on the SGI:",
"",
"\"TopLevelShell*TextEdit.TextFontColor:          grey80",
"\"TopLevelShell*TextEdit.font:                   screen15",
"",
"",
"3.  Window Types",
"",
"Pi provides four windows that are not associated with the debugging of a",
"particular process: the Unix Pi window, the Directory window, the Help window,",
"and the Keyboard Input window.  The use of these windows is summarized below:",
"",
" Unix Pi  This window attaches the debugger to Unix processes and core dumps,",
"          and is the first window created when the debugger is started.  You can",
"          start new programs from this window or attach to processes that are",
"          already running.  Pi supports concurrent debugging of multiple Unix",
"          processes by allowing multiple Process windows to be opened from the",
"          Unix Pi window.",
"",
" Directory",
"          Changes the current working directory of the debugger.",
"",
" Help     Describes the operators and user interface.",
"",
" Keyboard Input",
"          This window allows entered text to be edited, and keeps a history of",
"          the typed commands.  Keyboard input typed to any window is echoed",
"          here.",
"",
"For each process, you may create the set of windows shown below:",
"",
"                     Process",
"         +---------------+----------------+",
"         |               |                |",
"     DATA WINDOWS    CODE WINDOWS    OTHER WINDOWS",
"     ------------    ------------    -------------",
"     Memory          Assembler       Journal",
"     User Types      Source Files    Signals",
"     Globals         Source Text1    Breakpoints",
"     Frame1           ...",
"      ...            Source TextM",
"     FrameN",
"",
" Process      The focal point for examining a process or core dump.  The Process",
"              window displays the current status of the program, and when the",
"              program is stopped, a list of all the activation records (stack",
"              frames) on the stack.  The window's menus can be used to open all",
"              the other windows associated with the process, and to start, stop,",
"              step, or kill it.",
"",
" Source Files Lists the files compiled with the -g option that were used to",
"              construct the program.  The line menus allow the Source Text",
"              window for each file to be opened.",
"",
" Source Text  These windows are used to display source code, set and clear",
"              breakpoints, and open the Assembler and Frame windows.  Each file",
"              listed in the Source Files window has its own Source Text window.",
"",
" Assembler    For viewing assembly code and stepping the processor at the",
"              instruction level.  This window can be used to examine the code",
"              generated by the compiler, or to step through functions for which",
"              no symbolic debugging information is available.",
"",
" Frame        Used to examine C data structures in the context of an activation",
"              record.  Each activation record has its own Frame window, and the",
"              menu bar lists the function's local variables and arguments.  The",
"              keyboard language allows C expressions to be evaluated and the",
"              line menus provide extensive facilities for formatting data and",
"              traversing data structures.",
"",
" Globals      A Frame window for examining global variables.  Its menu bar lists",
"              the global variables.",
"",
" Memory       Allows memory to be examined as unstructured data.  Memory can be",
"              viewed as 1 (char), 2 (short), 4 (long, float), or 8 (double) byte",
"              cells and displayed in different formats.",
"",
" User Types   Allows you to examine and control the display of user defined",
"              types.  The menus may be used to choose which members of structs",
"              or unions are displayed, as well as their formats.",
"",
" Journal      Keeps a log of recent changes in the state of the program, such as",
"              hitting breakpoints and tracepoints, and stepping statements and",
"              instructions.",
"",
" Signals      Allows you to send a Unix signal to the process, and to select the",
"              signals that will be intercepted by the debugger when they are",
"              delivered to the process.",
"",
" Breakpoint   Lists the current breakpoints in the program.  Menu entries allow",
"              them to be cleared individually, or all at once.",
"",
"While all of the windows for a process are accessible from the Process window,",
"there are many different traversal paths between them.  For example, a Frame",
"window may be opened from the Process window, a Source Text window, the",
"Assembler window, or another Frame window.",
"",
"In typical debugging sessions, only a small fraction of the windows that may",
"potentially exist for a process are ever opened.  In simple debugging sessions",
"only three windows are usually needed: a Process window, a Source Text window,",
"and a Frame window.",
"",
"3.1  Help Conventions",
"",
"To allow you to find quickly the description of a window's contents, menus, and",
"keyboard operators, each window chapter has the following sections:",
"",
"     1. Window Overview",
"     2. Window Layout",
"     3. Menu Bar",
"     4. Window Keyboard Language",
"     5. Line Menus",
"     6. Line Keyboard Languages",
"",
"Sections may be missing if a window does not support a feature, such as line",
"menus.",
"",
"The following conventions are used to present the keyboard languages.  `|'",
"represents the or operator, and indicates either the item on the left or right",
"of the `|' may be used.  Optional items are enclosed in  \"[]\" brackets and a",
"variable number of items are represented by \"...\".  For example,",
"",
"     !program [arg1 ...]",
"",
"indicates you must type the character `!', followed by the file name of a",
"program, optionally followed by one or more arguments.  Similarly,",
"",
"     C_expression | ?string",
"",
"indicates either a C expression or a `?` character followed by a string is",
"required.",
"",
"3.2  Definitions",
"",
" activation record",
"            The area of memory on the stack that contains the local variables,",
"            arguments, and saved registers for a function.  Each active function",
"            has its own activation record.",
"",
" breakpoint A breakpoint causes a process to stop when the program counter",
"            reaches a specified address.  Breakpoints are implemented by",
"            replacing the original instruction at the address with special code",
"            that traps into the Unix kernel and suspends the process.  Hitting a",
"            breakpoint selects the source statement or assembly instruction",
"            where the breakpoint was set.",
"",
" callstack  All the activation records on the stack.",
"",
" conditional breakpoint",
"            A special type of breakpoint that when hit, evaluates a C expression",
"            and either stops the process or automatically resumes it depending",
"            on whether the expression is true or false.  When a conditional",
"            breakpoint is hit the source statement or assembly instruction where",
"            the breakpoint was set is selected and the value of the evaluated",
"            expression is displayed.  If multiple conditional breakpoints are",
"            set and their conditions are false, they flash in sequence as they",
"            are hit, providing a crude form of algorithm animation.",
"",
" core dump  A core dump is a file, usually named core, that contains the memory",
"            image of a program's data segment, stack segment, and registers.  A",
"            core dump is created by the operating system when certain signals",
"            are sent to a process and the process does not provide signal",
"            handlers.  Most core dumps are created by software bugs that cause",
"            detectable hardware errors, such as bus errors.",
"",
" hang       A Unix program provided with the debugger software that starts a",
"            program and suspends it before the first instruction is executed.",
"            The debugger may then attach to the program, providing a mechanism",
"            to debug the first instructions of program started from outside the",
"            debugger.",
"",
" instruction A machine (assembly level) instruction.  Stepping the processor one",
"            instruction executes one machine instruction.",
"",
" lvalue     A C expression that refers to a manipulatable region of storage.  A",
"            C expression that may legally be placed on the left side of an",
"            assignment statement is a lvalue expression.  If it makes sense to",
"            take the address of an expression with the `&' operator, than the",
"            expression is a lvalue.",
"",
" open a window",
"            In the discussion of many of the operators the phrase \"open a",
"            window\" is used.  For example, choosing the \"Globals\" menu entry",
"            opens the Globals window.  In this context, opening the window means",
"            if the window has not been previously opened, it will be placed on",
"            the screen.  If the window has already been created, opening the",
"            window brings it to the top of the window hierarchy, fully exposing",
"            it.",
"",
" spy        A C expression that is evaluated every time the process stops.  If a",
"            process is running, spy expressions are evaluated once a second.  A",
"            spy expression that changes at a conditional breakpoint or while",
"            instruction or statement stepping causes the process to be",
"            suspended.",
"",
" stack frame Another name for an activation record.",
"",
" statement  The code implementing a C or C++ statement.  Stepping the processor",
"            one statement will execute all the instructions corresponding to",
"            that statement.",
"",
" tracepoint A special type of conditional breakpoint, where the evaluated",
"            condition is 0, and thus always false.  When a tracepoint is hit the",
"            source statement or assembly instruction where the tracepoint was",
"            set is selected.  If multiple tracepoints are set, they flash in",
"            sequence as they are hit, providing a crude form of algorithm",
"            animation.",
"",
"",
"4.  Unix Pi Window",
"",
"The Unix Pi window attaches the debugger to Unix processes and core dumps, and",
"is the first window created when pi is started.  Pi provides several options for",
"attaching to programs.  Programs may be started from within the debugger, or the",
"debugger may attach to existing Unix processes.  A running program may be",
"attached to by typing its process id number to the window, or the mouse may be",
"used to list your current processes and select the ones you want to examine.",
"When a process is opened pi gives you the option to create a new window",
"hierarchy to examine it, or to take over an existing window hierarchy that you",
"have already set up to debug a different instance of the same program.",
"",
"Pi does not provide a window for the standard input and output of a process,",
"under the assumption that if the process needs terminal I/O services, it will be",
"started outside of pi and dynamic binding will be used to attach to it.",
"Programs started from within pi have their standard input, output, and error",
"file descriptors initialized to the special device /dev/null.",
"",
"If you start a program outside of pi, it may execute a fair amount of code",
"before you can attach the debugger to it.  If the program is short and does not",
"make any system calls that block, it will probably exit before you get a chance",
"to see what it is doing.  To debug the first instructions in these",
"circumstances, there is a Unix program called hang (provided with the pi",
"software) that starts a new process using the exec system call, and suspends it",
"before it executes the first instruction by sending it a SIGSTOP signal.  Pi may",
"then attach to the suspended process.  The syntax of hang is:",
"",
"     hang program [arg1 ...]",
"",
"Hang outputs the process id and name of program on its standard error file",
"descriptor before the program starts.  For example, if the shell's prompt is the",
"character `$', the following is the output of starting the program t with hang:",
"",
"     $ hang t",
"     2854 t",
"",
"Hang's output is in one of the formats accepted by the Unix Pi window's keyboard",
"interpreter, so to attach pi to a program started with hang quickly:",
"",
"  1.  Put hang's output into the cut buffer of the window system",
"",
"  2.  Select the Unix Pi window",
"",
"  3.  Paste the cut buffer into the Keyboard Input window.",
"",
"4.1  Unix Pi Layout",
"",
"Each line in the Unix Pi window represents either a Unix process, a core dump,",
"or a command line used to start a new process.  Lines that start with numbers,",
"such as",
"",
"     2292 q0 S 0:55 pads",
"     2294 test1",
"",
"represent Unix processes.  The number on the left of the line is the process id,",
"while the rest of the line is the name of the program or the output from the",
"Unix ps command.  Lines that start with the character `!', such as",
"",
"     ! a.out",
"",
"start new processes under the control of the debugger.  The rest of the line is",
"the command to run. The other lines, such as",
"",
"     core a.out",
"",
"open core dumps.  The file on the left is the name of the core dump and the file",
"on the right is the name of the program that generated it.",
"",
"The core dump and !command lines are typed in from the keyboard, while lines",
"representing Unix processes may be either typed in or generated by running the",
"Unix ps command from the window's \"ps\" menu.  By selecting a line and generating",
"its line menu, you may attach the debugger to the running program, examine the",
"core dump, or start a new program.",
"",
"When the Unix Pi window is initially opened, it contains two default lines:",
"",
"     !a.out",
"     core a.out",
"",
"that allow the program a.out to be started, or the core dump, core, created by",
"an errant a.out to be opened.  These lines also serve as templates to remind you",
"of the window's keyboard syntax.",
"",
"4.2  Unix Pi Menu Bar",
"",
"The menu bar in the Unix Pi window allows you to list selected groups of",
"processes in the window, bring up the help window, or quit the debugger.  The",
"\"ps\" menu contains the following entries on Unix System VR4 based systems (the",
"entries may be slightly different with other versions of the Unix operating",
"system):",
"",
" /bin/ps -u user Run the Unix command in the menu entry to generate a list of",
"                 your current processes, and place its output in the window.",
"                 You may attach the debugger to a process by selecting its line",
"                 and using its line menu.  The lines are sorted by process id",
"                 number, and previous entries with the same process id number",
"                 are removed.",
"",
" /bin/ps -a      Same as above except the processes owned by other users are",
"                 also listed.  Unless you have super-user permissions obtained",
"                 with the Unix command su, you will not be able to attach to",
"                 programs you do not own.",
"",
" /bin/ps -e      List every process on the system.  Only the super-user is",
"                 allowed to attach to programs owned by others.",
"",
"The \"help\" and \"quit\" buttons do the following:",
"",
" help            Open the Help window.",
"",
" quit            Quit the debugger and detach from all processes.  A pop-up",
"                 window will ask you to confirm this choice.",
"",
"4.3  Unix Pi Keyboard",
"",
"Syntax",
"",
"     !program [arg1 ...]",
"     [*]pid [program]",
"     [*]corefile program",
"",
"The Unix Pi window's keyboard interpreter accepts three different input formats",
"that allow you to start a new process, attach to an existing process, or examine",
"a core dump.  The first format:",
"",
"     !program [arg1 ...]",
"",
"starts a new process from pi.  Program is the name of the executable file that",
"contains the code and symbol table information.  The optional arguments are",
"passed to the program when it is started.  When the text is entered, pi adds a",
"line to the window and selects it, but does not start the program.  The line's",
"menu provides options to start the program in a new Process window or to take",
"over an existing set of windows.  Since entering the line in the window is a",
"separate operation from starting the program, the same line may be used to start",
"the program several times.",
"",
"The second format:",
"",
"     [*]pid [program]",
"",
"attaches to processes that are already running.  Pid is the process id number",
"and program is the name of the file containing the symbol table.  If the",
"operating system supports mounted processes the program name is optional and if",
"not present, the system will open the correct file automatically.  Mounted",
"processes are currently supported on systems running Unix System VR4 and its",
"derivatives.  If a program name is given pi searches for it on your PATH.  If",
"not preceded by the optional `*', the line will simply be entered in the window",
"and you will have to use the line's menu to attach the debugger to the process.",
"The line menu gives you the option of opening the process in a new set of",
"windows or attaching to a preexisting set, just like the menu for lines that",
"start with `!'.  If the entry is preceded by the character `*', a new Process",
"window for the process will be automatically opened when the text is entered.",
"`*' is an accelerator for selecting the \"open process\" menu entry in the newly",
"entered line.",
"",
"The third format:",
"",
"     [*]corefile program",
"",
"examines core dumps.  Corefile is the name of the core dump file, usually core,",
"and program is the name of the file containing the symbol table.  As the syntax",
"for core dumps is the same as that used for attaching to processes, the Unix Pi",
"window distinguishes the two by the name of the corefile.  If corefile contains",
"only digits, pi assumes it is a process id.  Otherwise, its a core dump file.",
"If you plan to use pi with core dumps, don't rename the core file with a name",
"that contains only digits!  As above, the optional `*' is an accelerator for",
"opening the core dump without using the menus.  In the current implementation a",
"core dump cannot take over an existing set of windows.",
"",
"4.4  Unix Pi Line Menus",
"",
"The line menu depends on the format of the selected line.  Lines in the format",
"\"!program [arg1 ...]\" start new processes and the menu contains the following",
"entries:",
"",
" hang & open proc  Start the process from the debugger using the execp() system",
"                   call, and suspend it before it executes the first",
"                   instruction.  The program may be in any directory on your",
"                   PATH.  As pi does not provide a process with a window for",
"                   terminal I/O, the new process will have its standard input,",
"                   output and error file descriptors initialized to /dev/null.",
"                   Other than redirection of the file descriptors, this is",
"                   equivalent to using hang to start the process outside of pi.",
"                   After the process is created, a new Process window is opened",
"                   for it and a new entry of the form:",
"",
"                        pid program",
"",
"                   where pid is the process id of the new process, is added to",
"                   the Unix Pi window.",
"",
" hang & take over  This entry is similar to \"hang & open proc\", except rather",
"                   than creating a new set of windows, you will be asked to",
"                   choose an existing set of windows to take over.  A pop-up",
"                   window will ask you to select the process window hierarchy to",
"                   take over.  To work successfully, the process chosen must be",
"                   another instance of the same program.  If successful, the",
"                   debugger will detach itself from the Unix process that window",
"                   was previously connected to, and attach to the new one.  In",
"                   addition to the windows, the new process inherits all the",
"                   breakpoints that were set in the previous process.  This menu",
"                   entry is particularly useful if while debugging a program,",
"                   you discover you have gone too far, and would like to rerun",
"                   the program without going through the effort of opening the",
"                   windows, resetting the data formatting options, and placing",
"                   the breakpoints.",
"",
"If the line in the pi window starts with a process id number, either from a line",
"typed to the window or from the output of the ps command, the menu contains the",
"following entries:",
"",
" open process  Attach the debugger to the process and open a new Process window",
"               for it.  On systems with the /proc file system, pi will locate",
"               the file containing the symbol table automatically.  On other",
"               systems the file containing the symbol table must be in the",
"               current directory or somewhere on your PATH to successfully open",
"               the process.  On systems without /proc, if the line was generated",
"               by a ps menu entry the program name is taken from the COMMAND",
"               field.",
"",
" take over     Similar to \"open process\", except instead of creating a new set",
"               of windows, you will be asked to choose an existing set of",
"               windows to take over.",
"",
" open child    Attach the debugger to the child of a debugged process.  When a",
"               process being debugged calls the Unix system call fork, the child",
"               process inherits the parent's memory, and thus any breakpoints",
"               that were set in the code.  When the debugger attaches to the",
"               child, the breakpoints inherited from the parent must first be",
"               removed.  To use this entry:",
"",
"                 1.  Execute the fork() in the parent process at full speed.",
"",
"                 2.  Choose the \"ps\" entry in the menu bar.",
"",
"                 3.  Select the line in the window corresponding to the new",
"                     child process.",
"",
"                 4.  Choose the \"open child\" entry in the line menu.",
"",
"If the line starts with neither `!' or a process id (all digits), the line must",
"be in the format used to open core dumps, \"corefile program\", and the menu",
"contains:",
"",
" open coredump   Open the Process window for the core dump.  Corefile must be",
"                 accessible from the current directory as pi does not search for",
"                 it on your PATH.",
"",
"",
"5.  Process Window",
"",
"The Process window is the focal point for examining a process or core dump.  The",
"window displays the current status of the program, and when the program is",
"stopped, a list of all the activation records (stack frames) on the stack.  The",
"menus can be used to open all the other windows associated with the process, and",
"to control the process at the statement level.",
"",
"5.1  Process Layout",
"",
"The title bar identifies the window as a Process window and displays the process",
"id number or name of the core file.  The first line in the window lists the",
"current status of the process along with the current value of the program",
"counter (pc).",
"",
"The pc is displayed in one of two formats.  If the pc points to a routine that",
"pi has symbolic source file and line information for (the function was compiled",
"with the -g option), the file and line number are displayed as shown below.",
"",
"     file:linenumber+offset",
"",
"The offset is the difference in bytes between the current pc and the address of",
"the first instruction implementing the line number.  If symbolic information is",
"not available for the function, or the pc is in a function prologue, the name of",
"the function will be used in place of the file name and line number.",
"",
"     function()+offset",
"",
"Here the offset is the difference in bytes between the pc the starting address",
"of the function.  These address formats are also used in the Assembler window,",
"Frame window title bars, and the Breakpoint window.",
"",
"The possible status lines and their meanings are listed below:",
"",
" RUNNING: pc=address",
"       The program is currently executing.  While a process is running, pi",
"       updates the status line by polling the process once a second.",
"",
" STOPPED: pc=address",
"       The process has stopped from a SIGSTOP signal, usually from selecting the",
"       \"stop\" entry in the \"stmt\" menu.",
"",
" BREAKPOINT:",
"       The process is stopped at a breakpoint.  When a breakpoint is hit pi",
"       selects the source statement in a Source Text window or assembler",
"       instruction in the Assembler window where the breakpoint was set.",
"",
" STMT STEPPED: pc=address",
"       The process has stopped after stepping a statement.",
"",
" INSTR STEPPED: pc=address",
"       The process has stopped after stepping an assembler instruction.",
"",
" EVENT PENDING: bus error",
"       The process stopped because a signal was received.  The exact message",
"       depends on the signal.  Signals sent to the process are intercepted by",
"       the debugger, which allows you to either cancel the signal, or send it on",
"       to the process.  To send the signal, just resume executing the process.",
"       To cancel it, use the menu bar in the Signals window.  The Signals window",
"       allows you to choose which signals are intercepted by the debugger.  This",
"       status line is displayed when core dumps are examined.",
"",
" ERROR STATE: exited with status 9",
"       The process exited or died from a signal.  No further debugging may be",
"       performed on the process.",
"",
" step N statements|instructions",
"       The process is being stepped a large number of statements or",
"       instructions.  N is the number of remaining steps and will count down.",
"",
"The second line in the window is for error messages.  For example, when program",
"is started from the debugger with the \"hang & open proc\" menu entry in the Unix",
"Pi window, the first two lines in the Process window initially are:",
"",
"     STOPPED: pc=start()",
"     cannot obtain callstack",
"",
"indicating that no activation records were found.  Until the program executes",
"the first subroutine call, there are no activation records on the stack.  In",
"normal operation the second line in the window is blank.",
"",
"If the process is stopped, line 3 and below list the activation records on the",
"stack, one per line, from the most recently called function to the oldest.",
"Unless you use a special start-off file, the activation record on the bottom",
"line of the Process window is a call to main().",
"",
"Each activation record lists the symbolic value of the pc, the function name,",
"and any arguments (parameters).  Activation records for functions compiled with",
"the -g option have the following format:",
"",
"     file:linenumber+offset function(arg=value ... )",
"",
"The number of arguments, as well as their names and type depends on the",
"function's declarations.  Functions for which symbolic information is not",
"available are displayed in the following format:",
"",
"     function+offset function()",
"",
"The list of activation records is updated every time the process stops, although",
"when stepping multiple statements or instructions, the list is not updated until",
"after the last step.  The Process window limits the display to the top 1000",
"activation records, which should be adequate for all but the deepest recursive",
"functions.",
"",
"5.2  Process Menu Bar",
"",
"The menu bar contains the \"views\" and \"stmt\" menus, along with a \"kill\" button.",
"The \"views\" menu allows the other windows associated with the process to be",
"opened and contains the following entries:",
"",
" Source      Open the Source Files window for the program.  The Source Files",
"             window lists the files compiled with the -g option that were used",
"             to construct the program.  If the program was constructed from a",
"             single source file, this entry opens the Source Text window for",
"             that file directly.",
"",
" Globals     Open the Globals window, a Frame window that accesses global",
"             variables. The menu bar in the Globals window lists all the global",
"             variables.",
"",
" Memory      Open the Memory window, allowing memory to be examined as a",
"             sequence of cells.",
"",
" Assembler   Open the Assembler window.  Used to debug assembly code and examine",
"             the instructions generated by the compiler.",
"",
" User Types  Open the User Types window.  Used to view the declarations for the",
"             program's structs and unions and to set the default fields and",
"             formats that are displayed when instances of these types are",
"             examined.",
"",
" Journal     Open the Journal window.  This window keeps a log of recent changes",
"             in the state of the process.",
"",
" Signals     Open the Signals window.  Used to send signals to the process and",
"             intercept signals sent to the process.",
"",
" Breakpoints Open the Breakpoint window.",
"",
"The \"stmt\" menu controls the process at the source code statement level and",
"contains the following entries.  When debugging source code, it is recommended",
"that the pushpin in the \"stmt\" menu be placed in the hole, so the menu remains",
"visible on the screen.",
"",
" run       Run continues a suspended application.  The application will continue",
"           running until one of the following happens:",
"",
"             1.  A breakpoint is hit.",
"",
"             2.  A conditional breakpoint is hit and the condition is true.",
"",
"             3.  A tracepoint or conditional breakpoint is hit and the value of",
"                 a spy expression changes.",
"",
"             4.  A \"stop\" request is sent.",
"",
"             5.  The application receives a signal that is being traced.",
"",
"             6.  An error occurs.",
"",
"             7.  The application exits.",
"",
"           While running, pi polls the program once a second to determine its",
"           status and to evaluate any spy expressions.",
"",
" stop      Stop suspends a running application by sending the Unix signal",
"           SIGSTOP.  The stop operator does not wait for the process to stop,",
"           but pi will notice the arrival of SIGSTOP the next time it checks the",
"           status of the program.",
"",
" current   Open the Source Text window and select the source line corresponding",
"           to the current program counter.",
"",
" return    Run the process at full speed until the top activation record on the",
"           stack returns.  When the process stops, the source line corresponding",
"           to the new program counter is selected.  If the attempt to return",
"           takes more than 15 seconds to execute (usually because a function",
"           call is complicated or blocks in a system call), pi will stop the",
"           process.",
"",
" step into By default, stepping a statement steps over any function calls.  This",
"           entry causes pi to step into any functions it encounters in the",
"           statement.  When you step into a function for which pi has symbolic",
"           debugging information, pi opens the Source Text window for the file",
"           containing that function, and selects the function's first source",
"           line.  If after getting into a function you decide you really didn't",
"           want to step into it, you may get out of the function with the",
"           \"return\" operator.",
"",
" step N    Single step the process N statements, stepping over any function",
"           calls.  Before the process is stepped, all the breakpoints are",
"           temporarily removed.  After each step, the number of remaining",
"           statements is printed in the Process window and any spy expressions",
"           are evaluated.  If any of the spy expressions change value, pi stops",
"           stepping.  When the stepping is finished, the source line",
"           corresponding to the new program counter is selected.  If you attempt",
"           to step over a statement that takes more than 15 seconds to execute",
"           (usually because a function call is complicated or blocks in a system",
"           call), pi will stop the process.",
"",
"Stepping large numbers of statements is useful when used in combination with spy",
"expressions (see \"Spies\").  For example, if you don't know which statement is",
"changing a memory location's value, you can make the memory location a spy and",
"step a large number of statements.  Pi will stop at the first statement after",
"the value of the memory location changes.",
"",
"The \"return\" entry is useful if you step into a function with \"step into\" and",
"then decide after getting into the function, that you really didn't want to.",
"For example, suppose you want to step into the function f() in the following C",
"statement:",
"",
"     f(g());",
"",
"If you choose \"step into\" you will first step into the function g(), as it is",
"the first function encountered in the statement.  After stepping into g(), you",
"can step out of g() and into f() by:",
"",
"  1.  Selecting \"return\" to get out of g().",
"",
"  2.  Reselecting \"step into\" to step into f().",
"",
"This sequence is much simpler than other alternatives, such as setting a",
"breakpoint at the end of g() and removing it after hitting it, or setting and",
"removing a breakpoint before the call to f() in the Assembler window.",
"",
"The \"kill\" button kills the process by sending it the Unix signal SIGKILL.",
"Since this operation is irrevocable, pi will ask you to confirm this selection",
"with a pop-up window.",
"",
"If a Process window is closed, either by selecting \"close\" in the \"edit\" menu or",
"using the window manager, pi disconnects the debugger from the process and",
"closes all other windows associated with it.  The process is left in the state",
"it was in at the time of the closing, i.e. running programs continue executing",
"and programs suspended at a breakpoint or stopped, are disconnected in the",
"suspended state.",
"",
"When a Process window is created errors may occur that prevent pi from",
"completing the initialization procedure.  In these cases, the Process window",
"contains an error message and the menu bar contain entries that allow you to",
"complete the initialization.  For example, when attaching to programs started",
"outside of the debugger under SunOS, pi may successfully attach to the process",
"with ptrace, but not be able to open the file containing the symbol table",
"because it is not in the current directory or in one of the directories on your",
"PATH.  If this happens, the second line in the Process window contains the error",
"message:",
"",
"     symbol tables: No such file or directory",
"",
"and the menu bar contains the single entry, \"open process\".  At this point you",
"have the option to fix the problem by changing the current directory from the",
"Directory window and continuing the initialization from the menu, or disconnect",
"the debugger from the process by closing the Process window.",
"",
"5.3  Process Keyboard",
"",
"Syntax",
"",
"     function {|}|{} [condition]",
"     file:linenumber [condition]",
"",
"The keyboard language allows you to set breakpoints or conditional breakpoints",
"in a function by typing its name, or at a line in a source file.  The function",
"format allows you to set a breakpoint at a function's prologue, epilogue, or",
"both. For example, if x() is a C function, the input string:",
"",
"     x{",
"",
"is equivalent to opening the Source Text window for the file containing x(), and",
"placing a breakpoint at the first `{' after x()'s argument declarations.",
"Similarly:",
"",
"     x}",
"",
"places a breakpoint at x()'s closing `}' and:",
"",
"     x{}",
"",
"places a breakpoint at the starting `{' and closing `}'.  If the optional",
"condition is present the breakpoint becomes a conditional breakpoint, and",
"condition is the C expression evaluated.  If condition is 0, the breakpoint",
"becomes a tracepoint.  See \"Source Text Line Menus\" for more on breakpoints,",
"tracepoints, and conditional breakpoints.",
"",
"The file:linenumber format sets a breakpoint at the line number in the specified",
"file.",
"",
"The keyboard language of the Process window is used infrequently, as the",
"function format only allows breakpoints to be set at the function prologues and",
"epilogues, and the file format requires that you know line numbers.  If you know",
"the name of the file it is easier to open the Source Text window, scroll to the",
"line of interest, and place a breakpoint with the line menu, than to try to",
"remember line numbers.  However, there are two circumstances that make the",
"keyboard language useful.",
"",
"The \"function {\" format can be used if you want to see the source code of a",
"function that isn't listed in the activation records and you don't know what",
"file the function is in.  For example, suppose you want to look at the source",
"for function x().  If you type \"x{\" pi opens the Source Text window for the file",
"containing x(), displays the function x, and places the breakpoint in the",
"prologue.  If you really didn't want the breakpoint, you can remove it with the",
"line menu in the Source Text window.",
"",
"The file:linenumber format is intended to load a set of breakpoints from a file",
"generated by dumping the contents of a Breakpoint window.  This is useful if you",
"set up a complicated set of breakpoints and want to save them for future use, or",
"want to debug another instance of the same program concurrently, with the same",
"breakpoints.  The Process window's file:linenumber input syntax is the same as",
"the Breakpoint window's display format.  You may save the current set of",
"breakpoints in a file by opening the Breakpoint window and dumping the windows",
"contents with the keyboard command:",
"",
"     >cat > bkptfile",
"",
"To use bkptfile as the keyboard input to the Process window, place the keyboard",
"focus in the Process window and type:",
"",
"     <cat bkptfile",
"",
"However, since breakpoints placed using this technique are based on line",
"numbers, beware that editing the source files between the time the breakpoint",
"list is saved and read back in may cause the breakpoints to move.",
"",
"5.4  Process Line Menus",
"",
"The line menu for each activation record allows you to open the Frame window and",
"to see the source code associated with the record.",
"",
" open function() frame",
"          Open the Frame window for the activation record.  From the Frame",
"          window you can examine the function's arguments and local variables.",
"",
" show file:linenumber",
"          Open the Source Text window for the activation record and select the",
"          current source line, linenumber.  This entry only appear in the menu",
"          if symbolic line and file information is available for the function.",
"",
" return   This entry only appear in the menu for the top activation record in",
"          the window (most recent) and runs the process, at full speed, until",
"          the top activation record is no longer on the stack.  It is equivalent",
"          to \"return\" in the \"stmt\" menu in the Process window's menu bar.  It",
"          is not in the menu when core dumps are examined.",
"",
"",
"6.  Source Files Window",
"",
"The Source Files window lists the source files compiled with the -g option that",
"were used to construct the program.  From the line menus the files can be",
"opened.  The window is opened by selecting \"Source\" in the \"views\" menu in the",
"Process window's menu bar and is only created if there is more than one source",
"file.",
"",
"The window's keyboard language allows you to specify a list of directories to",
"search when source files are opened.  The search path may be initialized with",
"the PI_SRCPATH environment variable.  The menu bar allows different file path",
"name components to be used when files are located.",
"",
"6.1  Source Files Layout",
"",
"The title bar identifies the process id number or name of the core file.  Each",
"line lists the name of a source file.  Different options in the \"src\" menu allow",
"either the full path name, the file name given to the compiler on the command",
"line, or the last component in file name (the basename) to be displayed.",
"",
"If a directory search path has been set, the first line in the window will",
"displays the path:",
"",
"     Source Path: search_path",
"",
"The search path is a colon separated list of directories and is in same format",
"as the PATH environment variable used by the Bourne or Korn shell.  If a file",
"name displayed in the window is a relative path name (it doesn't start with \"/\")",
"pi searches for the file in the directories listed in the search path when the",
"Source Text window for that file is opened.  Pi searches for files that start",
"with \"./\" or \"../\" (path names relative to the current or parent of the current",
"directory) in the current directory before trying the search path.",
"",
"For example, if pi keeps its source code in the directory /usr/jtools/src/pi and",
"uses the pads interface library in the directory /usr/jtools/src/pads/host,",
"typing:",
"",
"     /usr/jtools/src/pi:/usr/jtools/src/pads/host",
"",
"to the window displays the following on the first line:",
"",
"     Source Path: /usr/jtools/src/pi:/usr/jtools/src/pads/host",
"",
"and source files in either directory will be found.",
"",
"In most cases, the use of a search path is unnecessary, since turning on the",
"full path name option in the \"src\" menu locates files in different directories.",
"However, this may fail for several reasons.",
"",
"  1.  The creation of temporary files during compilation may cause the full path",
"      information to be incorrect.  For instance, C++ translators based on",
"      cfront generate temporary C files.",
"",
"  2.  The files may have been moved.",
"",
"  3.  Some compilers do not store the full path names of the files in the symbol",
"      table.",
"",
"If the use of full path names fails, the search path may be used to locate",
"source files in different directories without changing the working directory of",
"the debugger.  A separate search path is maintained for each process.",
"",
"If the shell environment variable PI_SRCPATH is set, pi uses its value as the",
"initial setting for the source file search path.  In the example above you may",
"use the following Bourne shell commands to have the search path set",
"automatically each time pi is invoked:",
"",
"     PI_SRCPATH=/usr/jtools/src/pi:/usr/jtools/src/pads/host",
"     export PI_SRCPATH",
"",
"6.2  Source Files Menu Bar",
"",
"The \"src\" menu controls which components of the file path names are used to",
"locate source files.  If the displayed file name is a relative path name (it",
"doen't start with '/'), pi searches for the file in the search path directories",
"when it is opened.  The options are:",
"",
" default    Display the file names given to the compiler on the command line",
"            when the files were compiled.  This is the default option.",
"",
" basename   Display the last components of the file names.",
"",
" full path  Display the full path names of the files.  If the compiler does not",
"            store this information in the symbol tabe, this is equivalent to",
"            choosing \"default\".",
"",
"For example, if the file test1.c is compiled from the directory /usr/jtools with",
"the command line \"cc -g -c test/test1.c\", the file name is displayed as shown",
"below for the different options:",
"",
"     Option          File Name Displayed",
"     ---------       ------------------------",
"     default         test/test1.c",
"     basename        test1.c",
"     full path       /usr/jtools/test/test1.c",
"",
"If the directory search path is used, it should be set to \"/usr/jtools\" when the",
"\"default\" option is selected, and \"/usr/jtools/test\" when the \"basename\" option",
"is selected.",
"",
"6.3  Source Files Keyboard",
"",
"Syntax",
"",
"     search_path",
"",
"The keyboard language allows you to enter a list of directories to search when a",
"source file is opened.  The format of the search path is the same as the PATH",
"environment variable in the Bourne shell.  It consists of a list of directory",
"names separated by \":\" characters.  The directories are searched in the order",
"they are listed and the null string specifies the current directory. For",
"example, setting the search path to:",
"",
"     :/usr/jtools/src/pi:/usr/jtools/src/pads/host",
"",
"will search for a source file in sequence the current directory (the null string",
"before the first \":\"), /usr/jtools/src/pi and /usr/jtools/src/pads/host.  Unlike",
"the PATH in the Bourne shell, the current directory is searched even if it is",
"not in the search path.  There is an implicit \":\" on the end of the path.",
"",
"The current search path is displayed on the first line of the window.",
"Reentering a new search path overwrites the previous entry.",
"",
"6.4  Source Files Line Menus",
"",
"Each line listing a source file name generates the following menu.",
"",
" open source file   Open the Source Text window for the file.",
"",
"",
"7.  Source Text Window",
"",
"Source Text windows display source code.  Each source file has its own Source",
"Text window.  The menus set and clear breakpoints, open the Frame windows, show",
"the assembly code implementing a statement, and find functions in the file by",
"name.",
"",
"7.1  Source Text Layout",
"",
"The title bar displays the name of the source file.  Most of the lines in the",
"window display the source code without modification.  However, special character",
"sequences are inserted at the beginning of lines containing breakpoints.  If a",
"regular (unconditional) breakpoint is placed at a line, the characters \">>>\" are",
"inserted at the beginning.  When a breakpoint is hit, the process will stop",
"before the first assembler instruction implementing the statement is executed.",
"For example, the line",
"",
"     >>>     j++;",
"",
"stops the process before the variable j is incremented.  Hitting a breakpoint",
"causes pi to select the line in the Source Text window that set the breakpoint.",
"",
"Conditional breakpoints are breakpoints that evaluate a C expression when they",
"are hit, and either stop or continue the process depending on whether the",
"expression is true or false.  If you have set a conditional breakpoint at a line",
"with its line menu, but haven't specified the condition yet, the characters",
"",
"     if( ? ) >>>",
"",
"are placed on the beginning of the line, indicating the line is waiting for you",
"to type in the C expression to use for the condition.  After an expression has",
"been entered, the `?' character is replaced with the expression.  For example,",
"to stop on a line when the value of i is equal to 5:",
"",
"  1.  Select the line with the mouse.",
"",
"  2.  Choose the \"cond bpt\" entry in the line's menu.",
"",
"  3.  Type in the condition \"i==5\".",
"",
"The line will be redisplayed as",
"",
"     if(i==5)>>>     original_statement;",
"",
"The inserted text expresses that setting a conditional breakpoint is equivalent",
"to adding the C statement \"if(expression) >>>\" to the code, where \">>>\"",
"represents the breakpoint handler.",
"",
"When a conditional breakpoint is hit, the source line corresponding to the",
"breakpoint is selected and the C expression is evaluated and printed.  The",
"displayed format for the lines becomes:",
"",
"     if([count]expression=value)>>> original_statement;",
"",
"where count is the number of times the breakpoint has been hit, expression is",
"the C expression evaluated, and value is the expression's value.  The count is",
"an attribute of the source line, and not the breakpoint so if you remove the",
"breakpoint and later add another one, count reflects the cumulative hits to the",
"statement.",
"",
"When a conditional breakpoint is hit, the source line is selected and displayed",
"in reverse video whether the condition is true or false.  If the condition is",
"false the process starts executing again.  If you have several conditional",
"breakpoints set on different lines and their conditions are all false, they will",
"flash in sequence as the process hits them.  The sequence the source lines flash",
"in provides a primitive type of algorithm animation.",
"",
"Because conditional breakpoints display the values of any expressions evaluated,",
"the C comma operator is useful for tracing a set of variables in the condition.",
"If two expressions are separated by a comma, the expressions are evaluated",
"left-to-right, and the value of the left expression is discarded.  For example,",
"if the breakpoint condition is:",
"",
"     i, j, i==5",
"",
"each time the conditional breakpoint is hit, the values of the variables i and j",
"are displayed along with the value of the expression i==5, and when the value of",
"the expression i==5 is non-zero, the process stops.  This causes the line to be",
"displayed as:",
"",
"     if([6] i=5, j=29, i==5=1)>>>    original_statement;",
"",
"The format used to print the values of variables in conditional breakpoints is",
"inherited from their settings in Frame windows.",
"",
"A tracepoint is a special conditional breakpoint that uses 0 for the condition.",
"Since this condition is never non-zero, a tracepoint never stops the process.",
"Setting a tracepoint from the line menu inserts the characters",
"",
"     if(0)>>>",
"",
"at the beginning of the line.  When a tracepoint is hit, the line flashes and",
"the breakpoint count field is updated.  After the tracepoint is hit the first",
"time, the displayed format changes to:",
"",
"     if([count] 0=0)>>>      original_statement;",
"",
"7.2  Source Text Opening Errors",
"",
"When a Source Text window is opened, the file containing the source code is",
"opened and read into the window.  Several things can go wrong.  If pi cannot",
"open the file because you are in the wrong directory, the file is not on the",
"source file search path, or the file has moved, the error message:",
"",
"     cannot open: No such file or directory",
"",
"is placed on the first line in the Source Text window.  You have several options",
"for reopening the file.",
"",
"  1.  Enter a source file search path into the Source Files window using that",
"      window's keyboard language, and then choose the \"reopen\" button in the",
"      Source Text window's menu bar.  This search path will be used when opening",
"      any subsequent Source Text windows.  You can set the default value of the",
"      search path by setting the PI_SRCPATH environment variable before pi is",
"      started.",
"",
"  2.  Use the \"src\" menu in the Source Files window menu bar to try using the",
"      full path names extracted from the symbol table.",
"",
"  3.  Change the directory of the debugger from the Directory window, and then",
"      choose the \"reopen\" menu entry in the Source Text window's menu bar.",
"",
"  4.  Type in a correct file name to the Source Text window.  When the window is",
"      in this error state, the window's keyboard language accepts an alternate",
"      file name.  This is the easiest method if only a single file name needs to",
"      be overridden.",
"",
"Pi performs several consistency checks before the source file is read in.  The",
"modification date of the source file is compared with the modification date of",
"the executable file containing the symbol table to insure the source file hasn't",
"been modified since the program was compiled.  If the source file is newer, the",
"file is not read in and a message, such as:",
"",
"     modified since compilation at Tue May 15 10:48:39 1990",
"",
"is put on the first line to warn you that the program-address-to-source-code-",
"line mappings in the symbol table file may not be correct for this source file.",
"At this point, you may force pi to read in the file anyway, by selecting the",
"\"reopen\" button in the menu bar, or you may change the file being read in by",
"using one of the options given above.",
"",
"7.3  Source Text Menu Bar",
"",
" reopen     Reopen the source file and read it back into the window.  This entry",
"            is useful if you accidentally read in the wrong file.",
"",
" func index For each function in the source file this menu will contain an entry",
"            of the form \"function()...linenumber\".  These entries allow you to",
"            locate source code for a function in the file by name.  Choosing an",
"            entry displays the first line of source code for that function.  The",
"            entries are sorted alphabetically so they are easy to find.  If the",
"            file contains C++ code, the argument prototypes are also placed in",
"            the menu entries, allowing overloaded function names to be",
"            distinguished.",
"",
"7.4  Source Text Keyboard",
"",
"Syntax",
"",
"     /[string]",
"     ?string",
"     linenumber",
"",
"The window's keyboard language allows to you search for strings in the source",
"file, or select a line by its line number.  Note that every line in the Source",
"Text window provides a line keyboard language, so you must make sure no line is",
"selected in the window to send keyboard input to the window.",
"",
"The \"/[string]\" syntax searches forward in the window for the next instance of",
"string.  If a match is found, the window scrolls to that line and selects it.",
"The string is not a regular expression and must match the characters exactly.",
"The search begins on the last line that was selected in the window.  If no match",
"is found and the last line in the window is reached, the search will wrap around",
"and continue on the first line.  The string is optional and if not present, the",
"string used in the last search request will be used.",
"",
"The \"?string\" format searches backwards in the window for the string.  The",
"string is required because if the input line is the single character `?', pi's",
"help mechanism is invoked.",
"",
"The \"linenumber\" format scrolls the window to the given line number and selects",
"the line.  Line numbers are used infrequently in pi, as menus are usually used",
"to select source lines.",
"",
"7.5  Source Text Line Menus",
"",
" set bpt     Set a breakpoint at the selected line.  The characters \">>>\" are",
"             inserted at the beginning of the line to indicate a breakpoint has",
"             been set.  The breakpoint is set at the first instruction of the",
"             code that implements the line, so when the breakpoint is hit the",
"             process will stop before the statement is executed.  When a",
"             breakpoint is hit, pi selects the line in the Source Text window",
"             where it was set.",
"",
" trace on    Set a tracepoint at the selected line.  The characters \"if(0)>>>\"",
"             are inserted at the beginning of the line as an indicator.  Every",
"             time the tracepoint is hit the line will flash and the breakpoint",
"             counter for the line will be incremented.",
"",
" cond bpt    Set a conditional breakpoint at the selected line.  The characters",
"             \"if( ? )>>>\" are inserted at the beginning of the line, indicating",
"             you need to type in a C expression to use for the condition, and",
"             the keyboard language for the line changes to just C expressions.",
"             Any C expression that may be typed to a Frame window may be used",
"             for the conditional expression.  When an expression is entered, it",
"             will displayed on the line in place of the `?', and the breakpoint",
"             will be set in the code.",
"",
"             When a conditional breakpoint is hit, pi evaluates the C expression",
"             and display it's value on the line, along with the number of times",
"             the breakpoint has been hit.  If the expression has a non-zero",
"             value the process is stopped.  Otherwise, pi resumes the process.",
"",
" clear bpt   Clear the breakpoint set on the selected line.  This menu entry is",
"             only present for lines that have breakpoints.",
"",
" assembler   Open the Assembler window and disassemble the first instruction",
"             implementing the selected line.  The line menu in the Assembler",
"             window has entries that allow you to disassemble the following",
"             instructions, so you can easily examine all of the instructions",
"             implementing a line of source code.",
" open frame  Open the Frame window for the function that the selected line is",
"             in.  The Frame window can be used to examine the function's",
"             arguments and local variables.  If the function has been called",
"             recursively, the Frame window for the most recent activation record",
"             for the function will be opened, and the warning message:",
"",
"                  called recursively - deepest instance",
"",
"             is printed in the Frame window when it is opened.  If there are no",
"             activation records on the stack for the function, the error",
"             message:",
"",
"                  function() is not on callstack",
"",
"             is displayed on the second line of the Process window.",
"",
"If a single line of source code generates multiple functions, such as C++",
"template code or in-line functions that are not coded in-line, a more",
"complicated line menu is created that allows the functions to be treated",
"individually, or as a group.  For each function generated, an entry is placed in",
"the menu that lists the function's name.  From that entry, a sub-menu is",
"generated that provides the standard Source Text line operators for that",
"individual function.  In addition, an \"all\" entry at the bottom of the menu",
"allows breakpoints to be set and cleared in all the functions at once.  If the",
"\"all\" entry is used to set a conditional breakpoint in multiple functions, the",
"conditional expression must be valid in all of the functions.",
"",
"When a line menu operation is invoked in a Source Text window, such as setting a",
"breakpoint, pi uses the program-address to source-code-line mappings obtained",
"from the symbol table to determine the address in the program associated with",
"the line.  However, some lines, such as lines that are completely blank or lines",
"that only contain variable declarations, have no instructions associated with",
"them.  If a menu operation is performed on a source line that didn't generate",
"any code, the operation occurs on the first line after the selected line that",
"generated some code.  Don't be surprised if occasionally when you set a",
"breakpoint, the breakpoint is actually set on a line further down in the file!",
"For example, if you attempt to place a breakpoint in the white space in between",
"functions, the breakpoint will be placed in the prologue of the function after",
"the selected line (the line containing the function's leading {).",
"",
"If a single statement spans multiple lines, the operation is performed on the",
"last line implementing the statement.  For example, if a Source Text window",
"contains the following C code:",
"",
"     1 if (i < 0 ||",
"     2     i > 100 ||",
"     3     i == 50)",
"     4        statement;",
"",
"using the line menu to set a breakpoint on line 1, 2, or 3 causes the \">>>\"",
"breakpoint indicator to appear on line 3.",
"",
"If a source line generates code in multiple places, the operation is performed",
"on the first code associated with the line.  For example, the for loop in the",
"following the C code:",
"",
"     for(i = 0; i < 10; i++) {",
"            statement;",
"     }",
"",
"generates separate code for the initialization and iterative parts of the for",
"statement.  If you place a breakpoint on the \"for\" line, the breakpoint is",
"placed in the code implementing the initialization, and will only be hit when",
"the for loop is first entered.",
"",
"Some compilers arrange the program-address to source-code-line mappings in the",
"symbol table so that the code implementing the iterative part of the for loop is",
"mapped to the source line containing the for loop's closing `}', allowing",
"separate breakpoints to be set from the Source Text window on both the",
"initialization and iterative parts.  However, this has the side effect that when",
"statement stepping over the iterative part of the for loop, pi points to the",
"line containing the for loop's closing `}', instead of the line with the \"for\"",
"on it.",
"",
"7.6  Source Text Line Keyboard",
"",
"Most lines in the Source Text window accept the following keyboard input:",
"",
"Syntax",
"",
"     /[string]",
"     ?string",
"     C_expression",
"",
"The first two formats do forward and backward string searches and behave exactly",
"like the string searches in the window's keyboard language.  See \"Source Text",
"Keyboard\".",
"",
"Typing a C expression to a line is an accelerator for choosing the \"open frame\"",
"menu entry for that line, and typing the expression into the Frame window.  The",
"Frame window corresponding to the source line is opened, and the C expression is",
"evaluated and printed in that window.  For example, to see the current value of",
"the local variable i in a function, select any line of source code in that",
"function and type i followed by carriage return.",
"",
"The keyboard language for lines where conditional breakpoints have been set, but",
"the conditions have not been entered, only accept C expressions.  These lines",
"start with the string:",
"",
"     if( ? ) >>>",
"",
"indicating they are waiting for you to type in the C expression to use for the",
"condition. When the expression is entered,  the \"?\" is replaced by the",
"expression.",
"",
"",
"8.  Assembler Window",
"",
"This window disassembles code and steps the processor at the instruction level.",
"The window can examine code generated by the compiler, or code for which no",
"symbolic information is available.  From the line menus, breakpoints can be set",
"at individual instructions.  Even when debugging at the source level, the",
"Assembler window is useful as it allows you to stop the process in the middle of",
"a complex statement and examine the intermediate results.",
"",
"8.1  Assembler Layout",
"",
"The title bar identifies the window and displays the process id number or name",
"of the core dump file.  Each line in the window displays a disassembled",
"instruction.  The instructions are ordered in the window by address, and have",
"the format:",
"",
"     address: instruction",
"",
"An instruction's line menu lets you control the display format of both the",
"address and instruction.  Constants can be printed using symbolic labels or as",
"numbers in several different formats.",
"",
"If the symbolic format is enabled, addresses are displayed in the same format as",
"activation records in the Process window.  Addresses for which symbolic source",
"line number and file information is available are printed in the format:",
"",
"     file:linenumber+offset",
"",
"where offset is the difference in bytes between the address of the first",
"instruction implementing the source line, and the address of the current",
"instruction.  The offset may be displayed in either octal, hexadecimal, or",
"unsigned decimal, depending on the format settings.  Instructions in function",
"prologues or in functions that do not have symbolic source line and file",
"information are displayed in the format:",
"",
"     function()+offset",
"",
"If the symbolic format is disabled addresses are displayed as absolute numbers.",
"The instruction syntax depends on the assembly language used by the machine.  If",
"an instruction has a breakpoint set on it the displayed line starts with the",
"special character sequence \">>>\".",
"",
"You can easily find the assembler intructions associated with a line of source",
"code by:",
"",
"  1.  Selecting the source code line in the Source Text window and choosing its",
"      \"assembler\" line menu entry, causing the first instruction implementing",
"      the line to be disassembled.",
"",
"  2.  Choosing one of the entries in the \"next\" menu for the disassembled line",
"      in the Assembler window, causing the instructions that follow to be",
"      disassembled and displayed.",
"",
"From the line number part of the address fields you can determine how many",
"instructions the compiler needed to implement the line of source code.",
"",
"8.2  Assembler Menu Bar",
"",
"The \"instr\" menu controls the process at the instruction level and is modeled",
"after the \"stmt\" menu provided in the Process window.  When debugging at the",
"instruction level, it is recommended that the pushpin in the \"instr\" menu be",
"placed in the hole, so the menu remains on the screen.  The \"instr\" menu",
"contains the following entries:",
"",
" run       Continue a suspended application.  This is equivalent to choosing the",
"           \"run\" entry in the Process window's \"stmt\" menu.  See \"Process Menu",
"           Bar\" for the conditions that cause an executing program to stop.",
"",
" stop      Suspend the application program.",
"",
" current   Disassemble and display the instruction corresponding to the current",
"           program counter.  This is the only option available when a core dump",
"           is examined.",
"",
" return    Run the process at full speed until the top activation record on the",
"           stack returns.  Useful for stepping out of functions you did not",
"           intend to step into.  When the process stops, the instruction",
"           corresponding to the new program counter is disassembled and",
"           selected.",
"",
" step over If the instruction is not a function call, step one instruction.  If",
"           the instruction is a function call, run the function at full speed",
"           and stop at the first instruction after the call.  If you attempt to",
"           step over a function call that takes more than 15 seconds to execute",
"           (usually because the function call is complicated or blocks in a",
"           system call), pi will stop the process.",
"",
" step N    Step the number of instructions specified. After each step, the",
"           number of remaining instructions is printed in the Process window and",
"           any spy expressions are evaluated.  If any of the spy expressions",
"           change value, pi stops stepping. After the last step, the instruction",
"           corresponding to the new program counter is disassembled and",
"           selected.",
"",
"8.3  Assembler Keyboard",
"",
"Syntax",
"",
"      .=expression",
"",
"The window's keyboard language allows you to enter the address of an instruction",
"to disassemble.  When a line is typed, the expression is evaluated and the",
"instruction at the resulting address is disassembled.",
"",
"The assembler's expression grammar only accepts a subset of C expressions.  The",
"expression may be constructed from global identifiers, integer constants (C",
"character, integer, and explicit long constants), and the following C operators,",
"listed in order of decreasing precedence:",
"",
"     Operator        Associativity",
"     --------        -------------",
"     () []           left to right",
"     - &             right to left",
"     * / %           left to right",
"     + -             left to right",
"",
"For example, to disassemble the instruction at the hexadecimal address 0x2020,",
"type:",
"",
"      .=0x2020",
"",
"When a function name is used you must take the function's address using the `&'",
"operator rather than just using the function's name.  For example, to",
"disassemble the instruction starting 100 bytes after the start of the function",
"main, type:",
"",
"      .=&main+100",
"",
"The process registers are considered to be part of the global variable space, so",
"they may be used in assembler expressions.  For example, typing:",
"",
"      .=$pc",
"",
"is equivalent to choosing the \"current\" entry in the \"instr\" menu.",
"",
"8.4  Assembler Line Menus",
"",
" set bpt    Set a breakpoint at the selected instruction.  The characters \">>>\"",
"            are inserted at the beginning of the line to indicate a breakpoint",
"            is present.  When an instruction breakpoint is hit, pi selects its",
"            line in the Assembler window.  Conditional instruction breakpoints",
"            are not allowed.",
"",
" clr bpt    Clear the breakpoint set at the selected instruction.  This menu",
"            entry is only present for instructions that have breakpoints.",
"",
" src text   Open the Source Text window and select the line of source code that",
"            generated the instruction.  This menu entry only appears for",
"            instructions that are in functions for which pi has symbolic source",
"            file and line information.",
"",
" open frame Open the Frame window for the function that the selected line is in.",
"            The Frame window can be used to examine the function's arguments and",
"            local variables.  If the function does not have an activation record",
"            on the stack, a warning message will be printed on the second line",
"            in the Process window.  If the function has been called recursively",
"            a warning message will be printed in the Frame window when it is",
"            opened.  This entry is equivalent to the \"open frame\" entry in the",
"            Source Text line menus.",
"",
" next       This menu has entries that allow 1 to 100 of the instructions",
"            following the selected instruction to be disassembled. The",
"            formatting options for the disassembled instructions are inherited",
"            from the selected instruction.",
"",
" format     This menu allows the display format of the disassembled instruction",
"            to be changed.",
"",
" refresh    Reread the selected instruction's memory and disassemble it again.",
"            This should not be necessary unless the instruction's memory has",
"            been modified since the last time it was disassembled.  For example,",
"            patching an instruction from the Memory window or disassembling a",
"            breakpoint location of a running process will cause the disassembled",
"            instruction to change.",
"",
" raw mem    Open the Memory window and display the memory containing the",
"            selected instruction. Useful if you would like to see the encoding",
"            of an instruction or you would like to patch it.",
"",
"The \"format\" menu allows control over the format used to display instructions.",
"If a format attribute is currently on, the menu entry allows you to turn the",
"attribute off, and if the attribute is on, the menu allows you to turn the",
"attribute off.  When a format menu entry is chosen, the selected instruction is",
"redisplayed with the new formatting options.  By default, the symbolic and hex",
"formats are on, and the octal and sign_dec formats are off.",
"",
" octal on|off     Turn on|off the displaying of integer constants as octal",
"                  numbers.",
"",
" sign_dec on|off  Turn on|off the displaying of integer constants as signed",
"                  decimal numbers.",
"",
" hex on|off       Turn on|off the displaying of integer constants as hexadecimal",
"                  numbers.",
"",
" symbolic on|off  Turn on|off the symbolic displaying of addresses, registers,",
"                  and register offsets.  When a register containing a C register",
"                  variable is printed, the name of the variable will be printed",
"                  in addition to the register.  Similarly, offsets to C local",
"                  variables will be replaced by the local variable names.",
"                  Depending on the implementation of the machine's disassembler,",
"                  the symbolic display of register and local variables may not",
"                  be performed.",
"",
"Instructions displayed by choosing a \"next N\" entry in the \"next\" menu inherit",
"the display format of the instruction that generated the menu, so to change the",
"format for a block of displayed instructions, change the format of the first",
"instruction in the block with the \"format\" menu, and then choose one of the",
"\"next N\" entries for that instruction.",
"",
"The following table shows how one Motorola 68020 instruction is displayed when",
"various formatting options are selected:",
"",
"     Format Flags            Displayed Line",
"     --------------------    ------------------------------------------",
"     hex, symbolic           test1.c:21+0xC: addl d0,j(fp)",
"     octal, symbolic         test1.c:21+014: addl d0,j(fp)",
"     hex                     0x2326: addl d0,0xC(fp)",
"     sign_dec                8998: addl d0,12(fp)",
"     octal                   021446: addl d0,014(fp)",
"     hex, octal, sign_dec    021446=0x2326=8998: addl d0,014=0xC=12(fp)",
"",
"Notice that when the symbolic option is on, the displacement number in the",
"register indirect with displacement addressing mode is replaced with the name of",
"the argument or local variable.  If more than one of the hex, octal, and",
"sign_dec options are on, the character `=' is used to separate the display of",
"the same field in different formats.",
"",
"",
"",
"9.  Frame Windows",
"",
"Frame windows examine and modify C data structures in the context of an",
"activation record.  Each activation record has its own Frame window so there is",
"no ambiguity in deciding which instance of a variable should be used when",
"expressions are evaluated.  Expressions evaluated in a Frame window see the same",
"name space and values that code in the function associated with the activation",
"record would see when it is executing.  The name space is uniquely determined by",
"the selection of the window!",
"",
"A Frame window's menu bar allows the function's local variables and arguments to",
"be evaluated while the keyboard language accepts C expressions.  The line menus",
"provide extensive facilities for formatting the display and browsing through the",
"data structures.  Each variable has formatting attributes that allow you to",
"specify how all future references to that variable should be displayed.  The",
"window provides several specialized line menus and keyboard languages that are",
"appropriate for the type of the expression.  For example, the line menu for a",
"variable that is a struct contains entries for displaying each member.",
"",
"Unlike the other types of windows, the number of Frame windows a process may",
"have is a dynamic property of the state of the process.  As new function calls",
"place activation records on the stack, new Frame windows may be opened.  If an",
"open Frame window's activation record disappears because the function returns,",
"the window is closed.",
"",
"9.1  Frame Layout",
"",
"The title bar in a Frame window identifies the activation record that the window",
"corresponds to by displaying the function's name and arguments, and the symbolic",
"value of the program counter.  This is the same information displayed on the",
"activation record's line in the Process window.  The title bar is updated",
"whenever the process stops.",
"",
"Most lines in a Frame window display C expressions and their values, and have",
"the following format:",
"",
"     expression=value[=value...]",
"",
"The expression's value may be displayed several times in different formats,",
"depending on the formatting options that have been selected from the line's",
"menu.  Assignment operators (\"=\") within the expression are displayed with the",
"character sequence \":=\" (inherited from Pascal) to distinguish it from the \"=\"",
"used to delimit the expression from its value.  For example, the line:",
"",
"     (i:=10)=012=0xA=10",
"",
"assigns the value 10 to the integer variable i.  Here i's formatting options are",
"set so it is displayed in octal, hexadecimal, and signed decimal.",
"",
"Other lines, such as",
"",
"     typeof(argv): **char",
"",
"display information about the expressions.",
"",
"The Frame window provides specialized line menus and keyboard languages that",
"depend on the expression's type, making it simple to explore data structures in",
"the program. For example, a line correponding to an array provides a special",
"keyboard syntax for displaying all the members in a specified index range.",
"",
"Lines that start with the special character sequence \">>>\" are spies.  Normally,",
"an expression is only evaluated when it is entered into the window from the",
"keyboard or menus, or the \"eval $\" entry is selected in its line menu.  However,",
"by making an expression a spy with its line menu, pi automatically updates its",
"displayed value (see \"Spies\").",
"",
"9.2  Frame Menu Bar",
"",
"The menu bar in a Frame window has entries that allow you to examine the",
"activation record's local variables and arguments, see the source code for the",
"activation record, open the Frame window for the activation record's caller, and",
"to reevaluate any spy expressions.  The \"frame\" pull-down menu contains the",
"following entries:",
"",
" src text       Open the Source Text window for the file containing the",
"                activation record's function and select the source line that",
"                corresponds to the record's current instruction.  The file that",
"                will be opened and source line that will be selected can be",
"                determined from the symbolic address displayed in the window's",
"                title bar.  This entry only appears if symbolic source file and",
"                line information is available for the function.",
"",
" caller's frame Open the Frame window for the next activation record on the",
"                stack (the function's caller).  This entry does not appear in",
"                the menu for the Frame window that corresponds to the oldest",
"                activation record on the stack, which is usually a call to",
"                main().",
"",
" changed spies  Reevaluate and redisplay all the spy expressions in this window.",
"                Pi automatically reevaluates spy expressions whenever the",
"                process stops, or once a second if the process is running, so",
"                this entry is normally not be needed.  However, you may want to",
"                reevaluate the spy expressions if the process is stopped and you",
"                change the values of some variables from a different Frame",
"                window or the Memory window.  Also, if some of the memory is",
"                shared with another process the memory may change while the",
"                process is stopped.",
"",
"The \"vars\" pull-down menu contains the following entries:",
"",
" all      Display the values of all the variables listed in the \"vars\" menu.",
"          This is equivalent to selecting every variable entry in the \"vars\"",
"          menu.",
"",
" variable storage_class",
"          Selecting a variable's menu entry causes that variable to be displayed",
"          on a new line in the window.  The storage class tells whether the",
"          variable is an argument, automatic, register, static that is private",
"          to the function, or static that is private to the file.  A menu entry",
"          appears for each local variable and argument declared in the function,",
"          as well as the external static variables declared in the file",
"          containing the function.  The menu entries are sorted alphabetically.",
"",
"          Selecting one of these menu entries more than once displays that",
"          variable multiple times, allowing you to keep previous values of the",
"          variable displayed in the window.  If you want to update the value of",
"          a displayed variable without creating a new line, select the \"eval $\"",
"          entry in its line's menu.",
"",
"The \"regs\" menu contains the following entries:",
"",
" all      Display the values of all the registers in the \"regs\" menu.  This is",
"          equivalent to selecting all the other entries in the \"regs\" menu.",
"",
" $regname Every processor register has an entry in the menu.  Choosing a",
"          register entry displays that register's value in the context of the",
"          activation record.  When registers that are used to hold C variables",
"          are displayed, their values are what the code for that activation",
"          record would see when it executes.  If any of the more recent",
"          activation records saved those registers on the stack so the registers",
"          could be reused, pi recovers the saved values.  As a result, the same",
"          register may have different values in different Frame windows.",
"          Scratch registers and other registers that are not saved by function",
"          calls always display their current value.",
"",
"          The register sub-menu generated depends on the machine's architecture.",
"          See \"Processor Dependencies\" for the names of the registers on",
"          different architectures.",
"",
"The possible storage classes that appear in the \"variable storage_class\" menu",
"entries are:",
"",
" arg      An argument to the function.",
"",
" aut      A local automatic (auto) variable.",
"",
" reg      A register variable or argument.",
"",
" sta      A static variable declared in the function.",
"",
" Sta      An external static variable declared in the source file containing the",
"          function.",
"",
" Glb      A global.  Global variables will only appear in the window menu for",
"          the Globals window.",
"",
"For example, the C code on the left below generates the \"vars\" pull-down menu on",
"the right for one of f()'s Frame windows:",
"",
"     C code                                  \"vars\" Menu",
"     ---------------------                   -----------",
"     static int i;                           all",
"                                             i Sta",
"     f(j, k)                                 j arg",
"     int j;                                  k reg",
"     register k;                             l aut",
"     {                                       m reg",
"             int l;                          n sta",
"             register m;",
"             static int n;",
"             /* code */",
"     }",
"",
"Trailing \"'\" characters are placed after a variable's name in the \"vars\" menu if",
"the same name is declared several times in different scopes within a function.",
"For example:",
"",
"     C code                                  \"vars\" Menu",
"     ------------------------------          -----------",
"     static int i;                           all",
"                                             i     Sta",
"     f(i)                                    i'    arg",
"     int i;                                  i''   aut",
"     {                                       i'''  sta",
"             {                               i'''' reg",
"                     register int i;",
"             }",
"             {",
"                     static int i;",
"             }",
"             {",
"                     int i;",
"             }",
"     }",
"",
"In this case it is possible to decide the correspondence between an i in the",
"menu with the i in the code by its storage class.  Expressions typed from the",
"keyboard that contain i use the instance of the variable with the most trailing",
"\"'\" characters in the menu if the name is overloaded. Here, the i declared as a",
"register would be used.  It is not possible to access the other i variables from",
"the keyboard - only the menu entries can be used to access them.",
"",
"If all the i variables are have the same storage class, it may take some",
"detective work to determine the menu to source code correspondence.",
"Disassembling the source statements or trying to deduce the correspondence by",
"the variables' values usually works.  However, authors of such convoluted code",
"deserve to have some difficulty debugging their programs.",
"",
"9.3  Frame Keyboard",
"",
"Syntax",
"",
"     C expression",
"",
"A Frame window's keyboard language allows you to type in C expressions to be",
"evaluated in the context of the window's activation record.  After evaluation,",
"the expression and its current value are displayed on a new line in the window.",
"A displayed expression may be reformatted or reevaluated from its line menu.  It",
"is not necessary to stop the process before evaluating expressions.  They can be",
"evaluated on-the-fly, with minimal impact on the timing of the running process.",
"",
"The expressions may be constructed from identifiers, C constants (character,",
"integer, explicit long and float), function calls and most (but not all) of the",
"C operators.  The following table shows the operators accepted by the grammar,",
"along with their precedence and associativity.  Operators on the same line have",
"the same precedence and rows are in order of decreasing precedence.",
"",
"     Operator                Associativity",
"     ----------------        -------------",
"     () [] -> .              left to right",
"     ! ~ - * & sizeof        right to left",
"     * / %                   left to right",
"     + -                     left to right",
"     << >>                   left to right",
"     < <= > >=               left to right",
"     == >!=                  left to right",
"     &                       left to right",
"     ^                       left to right",
"     |                       left to right",
"     &&                      left to right",
"     ||                      left to right",
"     =                       right to left",
"     ,                       left to right",
"",
"The only differences between this precedence table in the one in book, \"The C",
"Programming Language\" [Kernighan 78], are:",
"",
"  1.  The prefix and postfix operators ++ and -- are not supported.",
"",
"  2.  The cast operator",
"",
"           ( type-name ) expression",
"",
"      is not accepted.  However, the window's line menus can be used to perform",
"      casts on expressions.",
"",
"  3.  The conditional operator",
"",
"           expression ? expression : expression",
"",
"      is not accepted.",
"",
"  4.  Compound assignment operators of the form:",
"",
"           expression op= expression",
"",
"      such as += and -= are not supported.  Only simple assignments are",
"      accepted.",
"",
"9.3.1  Identifiers",
"When searching for identifiers that are variable names pi searches the following",
"name spaces in sequence to locate the variable:",
"",
"  1.  The local name space for the function corresponding to the Frame window.",
"      This includes the function's arguments and local, auto, and static",
"      variables declared inside the function.  The values of the machine's",
"      registers are accessible by preceding the register name with the character",
"      `$'.  See \"Processor Dependencies\" for the names of registers on different",
"      processor types.",
"",
"  2.  The name space of external static variables declared in the file",
"      containing the source code for the function.",
"",
"  3.  The global name space for the process.  This includes all the C external",
"      variables.",
"",
"To allow the use of pi with de-mangled C++ names identifiers are allowed to have",
"the character sequence \"::\" embedded in them, even though it is illegal in C.",
"",
"The keyboard language provides a special syntax that allows expressions to",
"access local variables in other activation records.",
"",
"     { expression } function",
"",
"evaluates the expression in the context of the closest older activation record",
"on the stack for the named function.  For example, if the function main()",
"contains the local variable i and calls the function a(), that contains the",
"local variable j, you may type the expression:",
"",
"     j + {i}main",
"",
"in a()'s Frame window to add the value of j in a() to the i in main().",
"",
"The search for activation records that correspond to the named function starts",
"at the caller of the Frame window's activation record (the activation record",
"that is on the line below the Frame window's activation record in the Process",
"window), and continues until an activation record for the function is found or",
"the oldest record on the stack is reached.  If the function has been called",
"recursively and has multiple activation records on the stack, the expression",
"will be evaluated in first activation record found.  If the search makes it to",
"the oldest activation record without finding a record associated with the",
"function, the expression is evaluated in a context that only allows the",
"function's static variables to be accessed.  It is not possible to access the",
"arguments or local variables in activation records that are more recent than the",
"current Frame window's using the \"{expression}function\" syntax.",
"",
"9.3.2  Function Calls",
"The Frame window keyboard language allows function calls be included in",
"expressions.  When a function call is encountered pi runs the function at full",
"speed with all breakpoints removed, and uses the results returned by the",
"function in the expression.  If the function call does not return after running",
"for 15 seconds, the call is aborted.",
"",
"To be able to evaluate a function call in an expression, several conditions must",
"be met:",
"",
"  1.  The function must be compiled with the -g option.  Pi uses the type",
"      information generated by the -g option to check both the type and number",
"      of arguments given to the function call, as well as the return type.",
"",
"  2.  The process must be stopped.  However, it is okay to have function calls",
"      in conditional breakpoint expressions, or as spy expressions when",
"      statement or instruction stepping, since the process will be stopped when",
"      the function call is evaluated.  An error message of the form:",
"",
"           function(): context save: process not stopped",
"",
"      is be printed in the window if the process is running and you try to",
"      evaluate an expression containing a function call.  Function calls are not",
"      allowed when core dumps are examined.",
"",
"9.3.3  Built-In Functions",
"The Frame window keyboard language also provides two functions that are built",
"into the grammar.",
"",
"     typeof(expression)",
"",
"displays the type of the given expression.  If the expression is a variable, the",
"type information is extracted from the symbol table.  Otherwise, the type of the",
"evaluated expression's result is displayed.  The following table shows some C",
"variable declarations and how typeof displays their type:",
"",
"     Declaration             Displayed by typeof",
"     ---------------         -----------------------",
"     char c;                 typeof(c): char",
"     char *cp;               typeof(cp): *char",
"     char ca[5][10];         typeof(ca): [5][10]char",
"     *cpa[10];               typeof(cpa): [10]*char",
"",
"In addition, the built-in function",
"",
"     double fabs(double d)",
"",
"returns the absolute value of its argument d.",
"",
"9.4  Frame Lines",
"",
"The line menus and keyboard languages allow you to explore the data structures",
"and vary depending on the type of the expression.  For most lines the keyboard",
"language accepts the same C expressions as the Frame window's keyboard language,",
"with the exception that the identifier $ is a shorthand to represent the",
"expression on the current line.  For example, if the currently selected line",
"contains an expression that points to a variable that is accessed by following",
"many pointers in a linked list, you may assign 0 to that variable by simply",
"typing",
"",
"     $=0",
"",
"rather than retyping in the whole thing.  Some types of lines, like those used",
"to index array elements, provide specialized keyboard languages that allow",
"simple input sequences to be used to perform complex operations.",
"",
"The line menus for the various expressions depend on the expressions' type, and",
"are described in the sections that follow.  Within the menus, the character `$'",
"is used to represent the selected expression.",
"",
"9.4.1  Basic Data Types",
"The line menu for the basic data types, such as chars, shorts, ints, longs,",
"floats and doubles contains the entries shown below.  Many of these entries will",
"also appear in the line menus for other types of expressions.",
"",
" spy on $   Make the selected expression a spy (for more on spies see \"Spies\").",
"            The line is redisplayed with the characters \">>>\" inserted at the",
"            beginning.  This menu entry is not present if the current expression",
"            is already a spy or if a core dumps is being examined.",
"",
" unspy $    Turn off spying for the selected expression.  This menu entry only",
"            appears for expressions that are spies.",
"",
" eval $     Reevaluate and redisplay the selected expression.  Useful if the",
"            expression is not a spy and you want to update its value.",
"",
" & $        On a new line, create and display a new expression by taking the",
"            address of the selected expression.",
"",
" mem .=$    Open the Memory window and use the value of the current expression",
"            as the address of the memory location to examine.  This menu entry",
"            is not present if the value of the current expression is 0.",
"",
" cast $     This sub-menu allows you to cast the selected expression into a",
"            different data type or into a pointer to a different data type.  See",
"            \"Casting\".",
"",
" typeof $   Display the type of the selected expression.",
"",
" sizeof $   Display the size of the selected expression.  If the expression is a",
"            variable the size in bytes of the memory space allocated for that",
"            variable is displayed.  If the expression is not a lvalue (you can't",
"            apply the address operator & to it), the size of the expression's",
"            result is displayed.",
"",
" format     This sub-menu allows you to choose the format used to display the",
"            selected expression.  See \"Format Menus\" below.",
"",
"9.4.2  Format Menus",
"The format sub-menus allow you to change the format used to display an",
"expression.  Each menu contain sa list of different formats that are applicable",
"to the type of the expression.",
"",
"Choosing a formatting entry causes the expression to be reevaluated and",
"displayed with the newly selected format.  Menu entries for formatting options",
"that are currently enabled allow you to turn that option off, while entries for",
"formatting options that are disabled allow you to turn that option on.  If",
"multiple formatting options are turned on, each format displayed on the line",
"will be separated from the others with the `=' character.",
"",
"If the expression is a C variable, setting the format field affects the future",
"display of all instances of that variable.  For example, setting the format",
"field for an argument to a function will not only affect how that variable is",
"formatted on the current line, but also in the activation records listed in the",
"Process window, in conditional breakpoint expressions in Source Text windows,",
"and in the title bars of Frame windows.  Similarly, if the format attributes are",
"set for a member of a struct or union, they will be used when displaying all",
"future instances of that struct or union.",
"",
"The possible formats are described below:",
"",
" hex on|off       Display the number in hexadecimal.",
"",
" unsd_dec on|off  Display the number as an unsigned decimal number.",
"",
" sign_dec on|off  Display the number as a signed decimal number.",
" octal on|off     Display the number in octal.",
"",
" ascii on|off     Display the number as a sequence of ASCII characters.  The",
"                  number of characters displayed depends on the size of the",
"                  type.  Chars display 1 character, shorts 2 characters, and",
"                  ints, longs, and floats 4 characters.",
"",
" float on|off     Display the number as a float.  Up to 6 decimal places are",
"                  used.",
"",
" double on|off    Display the number as a double.  Up to 15 decimal places are",
"                  used.",
"",
" time on|off      Treat the number as a Unix representation of time (the number",
"                  of seconds since the epoch 00:00:00 GMT, January 1, 1970), and",
"                  display it as an ASCII date and time.",
"",
" symbolic on|off  Display the number as a symbolic address.  It will appear in",
"                  one of the following formats:",
"",
"                       file:linenumber+offset",
"                       function()+offset",
"                       global+offset",
"",
"                  depending on whether the address points to a text",
"                  (instruction) location for which symbolic file and line",
"                  information is available, a text address for which symbolic",
"                  line information is not available, or a data address.",
"",
" `ascii' on|off   Display the characters referenced by the character pointer or",
"                  in the character array as a C string.  The string is",
"                  terminated by the first null character reached, and is limited",
"                  in length to 20 characters.  If the string contains more than",
"                  20 characters, the string terminates with the special",
"                  character sequence \"...\" to indicate there is more.  This",
"                  entry is mutually exclusive of the ``\"wider\" on|off'' entry.",
"",
" `wider' on|off   Same as the entry ``\"ascii\" on|off'' except the length of the",
"                  string is limited to 200 characters instead of 20.  Used when",
"                  you want more of a long string displayed.  This entry is",
"                  mutually exclusive of the ``\"ascii\" on|off'' entry.",
"",
"The default formatting options for the basic data types are listed below:",
"",
"     Type            Default Format",
"     --------------------------------",
"     char            ascii, sign_dec",
"     short           sign_dec",
"     int             sign_dec",
"     long            sign_dec",
"     float           float",
"     double          double",
"     unsigned char   ascii, unsd_dec",
"     unsigned short  unsd_dec",
"     unsigned int    unsd_dec",
"     unsigned long   unsd_dec",
"     char*           hex,\"ascii\"",
"     unsigned char*  hex,\"ascii\"",
"     other*          hex",
"",
"If only a single formatting option is on for an expression, and you attempt to",
"turn it off, the formatting options for that expression will be reset to the",
"default for its type.",
"",
"9.4.3  Casting",
"The casting sub-menu allows expressions to be converted from one data type to",
"another.  Casting is not allowed from the keyboard and must be done from the",
"line menus.  While in most circumstances the type information maintained by the",
"symbol table makes casts unnecessary, there are several circumstances that",
"require their use:",
"",
"  1.  A variable's type information in the symbol table may be wrong if the",
"      variable was declared in a source file that was not compiled with the -g",
"      option.  These variables usually have their type field set to int or long,",
"      regardless of their real type.",
"",
"  2.  In C, it is common to use a single type of pointer to point to different",
"      types of objects.  For example, a generic linked list package may use a",
"      \"char *\" to point to all types of objects.",
"",
"  3.  If a C++ base class function is called for an instance of a derived class,",
"      you may want to cast the \"this\" argument for the function from a pointer",
"      to a base class object back into a pointer to a derived class object,",
"      allowing symbolic access to all its members.  Note, that while this works",
"      for derived classes that use single inheritance, it may not work with",
"      multiple inheritance.",
"",
"There are no int entries in the casting sub-menu as it is assumed that ints are",
"the same size as either shorts or longs.",
"",
" char       Cast the selected expression into a char.",
"",
" *char      Cast the selected expression into a pointer to a char.",
"",
" short      Cast the selected expression into a short.",
"",
" *short     Cast the selected expression into a pointer to a short.",
"",
" long       Cast the selected expression into a long.",
"",
" *long      Cast the selected expression into a pointer to a long.",
"",
" float      Cast the selected expression into a float.",
"",
" *float     Cast the selected expression into a pointer to a float.",
"",
" double     Cast the selected expression into a double.",
"",
" *double    Cast the selected expression into a pointer to a double.",
"",
" * ?        Cast the selected expression into a pointer to a type that will be",
"            specified later.  This menu operator casts expressions into pointers",
"            to pointers.  When this entry is selected a new line is created in",
"            the format:",
"",
"                 (* ? )expression",
"",
"            and the new line's menu is the cast menu.  Choosing an entry in the",
"            new line's cast menu creates another new line and replace the `?'",
"            character in the line with the cast type selected, and then perform",
"            the cast.  For example, if the global variable \"char **environ\",",
"            that points to the programs environment variables, was not declared",
"            in a file that was compiled with the -g option, the symbol table",
"            will falsely believe that its type is a long.  You may cast it back",
"            into its correct type by:",
"",
"              1.  Entering the expression \"environ\" from the keyboard.",
"",
"              2.  Choose the menu entry \"* ?\" in the cast sub-menu for that",
"                  line.  A new line:",
"",
"                       (* ? )environ",
"",
"                  is inserted in the window and selected.",
"",
"              3.  Choose the entry \"*char\" in the new line's menu and another",
"                  new line:",
"",
"                       (** char)environ=value",
"",
"                  is inserted into the window.",
"",
"            If you select the \"* ?\" entry in the menu for a line of the type",
"",
"                 (* ? )expression",
"",
"            a new line of the form",
"",
"                 (** ? )expression",
"",
"            is be inserted in the window, allowing you cast the expression into",
"            a pointer to a pointer to a pointer.  You may repeat this operation",
"            as many times as needed.",
"",
"            Although you may also use the \"* ?\" menu entry to cast an expression",
"            into a pointer to a basic data type, it is simpler to just choose a",
"            pointer entry in the original cast menu.",
"",
" *struct ?  Cast the selected expression into a pointer to a structure or union.",
"            A new line of the form:",
"",
"                 (*struct ? )expression",
"",
"            is inserted in the window and selected, indicating you need to",
"            specify the tag name of the structure or union.  The tag name may be",
"            entered from either the keyboard or line menu.  The keyboard",
"            language for the new line only accepts tag names.  When a tag name",
"            is entered, a new line is inserted in the window with the `?'",
"            replaced by the tag name and the cast is performed.",
"",
"            Alternatively, a tag name may be selected from the line's menu.  The",
"            menu will have an entry for every struct and union tag name found in",
"            the symbol table.  Selecting one of these entries is equivalent to",
"            typing that tag name in from the keyboard.",
"",
"            Unnamed structures have names generated for them automatically.  The",
"            format of these names is system dependent.",
"",
" enum ?     Cast the selected expression into an enum.  This menu entry behaves",
"            just like \"*struct ?\", except enum tag names are substituted for",
"            struct and union tag names.",
"",
"9.4.4  Arrays",
"The line menu for an array is the same as the line menu for the basic data types",
"except the cast operator is not in the menu as it is impossible to cast an array",
"into a different data type.  However, you may take the address of an array and",
"subsequently cast that into a pointer to a different type.",
"",
"In addition, an array's line menu provides an entry, \"$ []\", that allows to you",
"to access the elements of the array.  When this operator is chosen, a new line",
"of the form:",
"",
"     expression[ ? ]",
"",
"is placed in the window and selected.  This line's menu lists indices from -2 to",
"20 and selecting an entry will display that element of the array on a new line.",
"This same menu is generated when pointers are treated as arrays.  The negative",
"indices display elements that are located before the start of the array and are",
"useful with pointers that have been incremented since it is often desirable to",
"see what was previously pointed to.",
"",
"The keyboard language of a \"expression[ ? ]\" line provides an alternative way to",
"enter an array index.  The language accepts input in the form:",
"",
"     low[..high]",
"",
"where both low and the optional high are expressions that must have integer",
"values.  If only low is present, its value is used as an array index, and that",
"array element will be displayed on a new line.  This allows you to enter an",
"array index that is not in the range of the line menu, or is constructed from an",
"arbitrary C expression.",
"",
"If the low..high format is entered, all the elements from low to high are",
"displayed on new lines.  For example, to display the first 10 elements of an",
"array with a single command, type:",
"",
"     0..9",
"",
"The \"..\" operator used in the keyboard grammar has lower precedence than any of",
"the C operators.",
"",
"9.4.5  Pointers",
"The line menu for a pointer displayed in a Frame window is just like an array's,",
"except the \"cast\" sub-menu is present and an additional entry, \"* $\", allows you",
"to dereference the selected expression.  The \"$ []\" menu entry treats the",
"pointer as an array, and is useful for dereferencing all the elements in the",
"vicinity of the pointer.  For example, to display what the pointer points to, as",
"well as the five elements before and after it:",
"",
"  1.  Select the pointer's line and choose the \"$ []\" menu entry.  This creates",
"      and selects a new line of the form:",
"",
"           pointer[ ? ]",
"",
"  2.  Type the command",
"",
"           -5..5",
"",
"      to the new line to display the elements from 5 locations before the",
"      pointer to 5 locations after.",
"",
"9.4.6  Structures and Unions",
"The Frame window provides extensive facilities for displaying and exploring the",
"data in structures and unions.  A structure or union's line menu contains",
"entries that allow each of its members to be displayed.  These entries, along",
"with the \"typeof $\" menu entry and User Types window, provide a powerful way to",
"explore data structures you know little about.",
"",
"For each struct and union pi maintains a template of how to display an instance",
"of that type.  The template consists of:",
"",
"  1.  A list of the members that should be displayed.",
"",
"  2.  A list of formatting options for each member.",
"",
"The current display list and formatting options for a particular struct or union",
"can be viewed by choosing its tag name in the menu bar of the User Types window.",
"",
"The initial list of members to display consists of the first two members in the",
"declaration for that type, and can be modified several ways.  Members can be",
"explicitly added to the list by using the line menus in the User Types window.",
"Alternatively, a member may be added implicitly by displaying an expression in a",
"Frame window that accesses that member.  If you access a member of a struct or",
"union in an expression in a Frame window, either by typing in a C expression",
"from the keyboard or by creating it with the line menus, that member is",
"automatically added to the list of members to display for that type.  When any",
"instance of that struct or union type is displayed in the future, that member",
"will be shown.  Once a member is in the list of members to display, it can only",
"be removed from the list with the line menus in the User Types window.",
"",
"The formatting options used to display a member of a structure or union are",
"initially set to the default settings for its data type (see the \"Format Menus\"",
"section), and may also be modified from the line menus in either the User Types",
"or Frame windows.  If an expression in a Frame window displays a member of",
"structure or union, changing its displayed format with the \"format\" sub-menu",
"changes that members formatting options in the template.  The formatting option",
"selected affects the future display of that member in all instances of that",
"structure or union, not just in the selected expression.",
"",
"As an example we look at how pi displays the example of a structure given in the",
"\"The C Programming Language\" [Kernighan 78].  If our program contains the code:",
"",
"     struct date {",
"             int     day;",
"             int     month;",
"             int     year;",
"             int     yearday;",
"             char    mon_name[4];",
"     };",
"",
"     struct date d = { 4, 7, 1776, 186, \"Jul\" };",
"",
"and we ask pi to display the structure d in a Frame window (either by typing the",
"expression d to the window, or selecting d in its window menu), d is displayed",
"as:",
"",
"     d={day=4,month=7}",
"",
"The default format for a date structure displays the first two members, day and",
"month, as signed decimal numbers since they are both declared as ints.",
"",
"The line menu for this expression includes most of the operators provided for",
"the basic types along with some new ones, explained below:",
"",
"  spy on $     Make the selected expression a spy (see \"Spies\").  This is",
"               equivalent to spying on each of the members that are in the",
"               template's display list.",
"",
"  eval $       Evaluate and display all the members in the structure or union",
"               that are in the template's display list.",
"",
"  $.id         This sub-menu allows members of the structure or union to be",
"               examined.",
"",
"The \"$.id\" sub-menu entries are.",
"",
"  $.*          Display all the members of the struct or union on the selected",
"               line, adding them all to the list of members to display for that",
"               type.",
"",
"  $.member     For each member of the struct or union there will be a menu entry",
"               in this format. Choosing one of these entries displays that",
"               member on a new line in the window and adds that member to the",
"               list of members to display for that type.  The entries are sorted",
"               alphabetically in the menu.",
"",
"If a structure or union has only a few entries, the \"$.member\" and \"$.*\" menu",
"entries are placed directly in the line menu, and the \"$.id\" sub-menu is not",
"created.  While you may not cast a structure or union into a different type",
"directly, if you take its address with the \"& $\" menu operator, the new line's",
"menu will allow you to perform casts.",
"",
"If in the example above, if we choose the \"$.year\" menu entry, the line:",
"",
"     d.year=1776",
"",
"is inserted into the window.  Since this operation adds year to the list of",
"members to display for a date structure, if we select the line displaying d and",
"choose the \"eval $\" menu entry, the line is redisplayed as:",
"",
"     d={day=4,month=7,year=1776}",
"",
"Similarly, reselecting the line containing \"d.year=1776\" and choosing the \"hex",
"on\" menu entry in its \"format\" sub-menu, redisplays the line as:",
"",
"     d.year=0x6F0=1776",
"",
"As the format selection also becomes part of the template for the date",
"structure, reselecting the line displaying d and again choosing the \"eval $\"",
"menu entry redisplays that line as:",
"",
"     d={day=4,month=7,year=0x6F0=1776}",
"",
"To remove a member from the list of members to display you must",
"",
"  1.  open the User Types window.",
"",
"  2.  choose the structure or union's tag name in the window menu.",
"",
"  3.  and then choose the \"hide\" entry in the line menu for that member.",
"",
"See \"User Types\" for a detailed description of these operators.",
"",
"These techniques allow to you to specify exactly which members of a structure or",
"union are displayed, and how they are formatted.  When structures have large",
"numbers of entries, you can customize the display so only the members of",
"interest are shown.",
"",
"If an expression is a pointer to a structure or union, additional line menu",
"entries allow you to cast the structure pointer into other types and look at the",
"structure's memory from the Memory window.",
"",
" * $      Dereference the pointer, and on a new line display the structure or",
"          union as describe by its template.  Only members in the template's",
"          list of members to display are evaluated.",
"",
" $ []     Treat the structure pointer as an array of structures. See the",
"          \"Arrays\" section for the description of this operator.",
"",
" $->id    This sub-menu allows access to all the members of the structure or",
"          union, and is analogous to the \"$.id\" sub-menu for an expression that",
"          is a structure.  The selection of the \"$->*\" menu entry displays all",
"          the members of the structure or union on a new line, instead of the",
"          current one.",
"",
" format   This entry determines the format used to display the pointer, not the",
"          contents of the structure or union.",
"",
"9.4.7  Enumerations",
"By default, an enum expression displays its value symbolically.  For example, if",
"b is an enum variable, and its current value is ACTIVE, it is displayed as:",
"",
"     b=ACTIVE",
"",
"If the value of an enum expression is out of range (it contains a value for",
"which there is no enumeration identifier), the current value is displayed as a",
"cast:",
"",
"     b=(enum Behavs)10",
"",
"An enum's line menu contains the same entries as the line menu for an int,",
"except the format menu has a \"symbolic\" entry instead of a \"time\" entry.  By",
"default, only the \"symbolic\" format is on.  Turning a non-symbolic format entry",
"on allows you to see the enumeration identifier's value.  For example, selecting",
"the \"sign_dec on\" menu entry for the \"b=ACTIVE\" line redisplays it as:",
"",
"     b=3=ACTIVE",
"",
"When assigning values to an enum expression you may type in the enumeration",
"value symbolically, or as a number.",
"",
"9.4.8  Non-Lvalue Expressions",
"A non-lvalue expression is a C expression that you can not take the address of,",
"or put on the left side of an assignment statement.  Non-lvalue expressions",
"generate line menus identical to the menus for the basic types (presented in",
"\"Basic Data Types\") except the \"& $\" entry is missing.  The \"format\" sub-menu",
"generated depends on the expression's type.",
"",
"Expressions constructed from a single integer constant are useful for converting",
"constants to different formats.  For example, if the hexadecimal constant 0x1234",
"is typed to the window, it is displayed as:",
"",
"     0x1234=4660",
"",
"It is converted to a decimal number on the display line since that is the",
"default format for an int expression.  To convert it to octal select the \"octal",
"on\" entry in the \"format\" sub-menu, and the line is redisplayed as:",
"",
"     0x1234=011064=4660",
"",
"9.4.9  Spies",
"Expressions displayed in Frame windows are not updated unless you explicitly",
"request that the expression be reevaluated by choosing the \"eval $\" line menu",
"entry.  However, if an expression is made into a spy expression by choosing the",
"\"spy on $\" menu entry, pi reevaluates and updates its displayed value",
"automatically.",
"",
"The frequency spy expressions are updated depends on what the debugger is doing",
"to the process.  When instruction stepping from the \"instr\" menu, spy",
"expressions are updated after each instruction step.  When statement stepping",
"from the \"stmt\" menu, they are updated after each statement step.  Because it",
"usually takes many instructions to implement a single statement, spy expressions",
"are checked less frequently when statement stepping.",
"",
"If the process is not being stepped, spy expressions are reevaluated every time",
"the process stops.  This may be caused from hitting a breakpoint, tracepoint, or",
"conditional breakpoint, or from there being a signal pending for the process",
"(from an outside source or from a \"stop\" request sent from the Process window).",
"When conditional breakpoints are hit, spy expressions are reevaluated even if",
"the breakpoint condition is false and the process is restarted.",
"",
"Finally, if the process is running and not hitting any conditional breakpoints",
"or tracepoints, spy expressions are updated once a second - the same frequency",
"that the status line in the Process window is updated.",
"",
"If the values of any spy expression change from their previous values, the lines",
"containing the expressions are selected by the debugger and one of the messages:",
"",
"     1 spy changed",
"     number spies changed",
"",
"is inserted at the beginning of the status line in the Process window, depending",
"on how many spy expressions have changed.  In addition, if the process was being",
"statement or instruction stepped, or at a tracepoint or a conditional breakpoint",
"when the value of the spy expression changed, the process is stopped.",
"",
"One way to view spy expressions is that they are conditional breakpoints, with",
"the condition being the value of the expression is different from the last time",
"it was evaluated, that are placed at every instruction, statement, or",
"tracepoint, depending on how you execute the process.  For example, if you have",
"a wandering pointer that is changing the value of a variable, but you don't know",
"where the bad code is, you can make the variable a spy to locate the faulty",
"instructions.  Stepping instructions will locate the exact instruction that",
"changes the variable, but the overhead of evaluating spies after each",
"instruction makes it impractical to use if large numbers of instructions must be",
"executed before the variable changes.  Stepping statements has less overhead, as",
"the spies are only evaluated after each statement and function calls are stepped",
"over at full speed, but it does not localize the faulty code as well.  If the",
"fault occurs in a deeply nested function call, the statement the process stops",
"at may be far removed from the statement that caused the error.  Tracepoints",
"allow you to specify exactly where the spy expressions are evaluated, and can be",
"used efficiently when you have a good idea where the problem is.",
"",
"If a running process does not hit any conditional breakpoints or tracepoints",
"after executing for one second, spy expressions are reevaluated and redisplayed,",
"but the process is not stopped if any of their values change.  In this case, the",
"changed spy expressions do not stop the running program for two reasons.",
"",
"  1.  If it were stopped, the current location in the program would most likely",
"      have little to do with the changing of the spy expression.  Millions of",
"      instructions may have executed between the time expression changed values",
"      and the spy expression was evaluated.",
"",
"  2.  The automatic redisplay of changed spy expressions every second without",
"      stopping the program can be useful when debugging code that explicitly",
"      depends on the program's timing.  This feature allows you to monitor",
"      expressions in real-time, with minimal impact on the running program.",
"",
"If you are using spies to monitor expressions once a second in real-time, their",
"are two restrictions that apply to them:",
"",
"  1.  They may not contain any function calls, as pi cannot evaluate expressions",
"      containing function calls unless the process is stopped.",
"",
"  2.  Because pi does not update it's list of activation records until a process",
"      stops, you should be careful not to spy on local variables in activation",
"      records that will disappear when the program is resumed.  If a spy",
"      expression includes such a variable, pi will continue to update the",
"      expression as if the activation record were still present, but the value",
"      it reads will be determined by whatever the program uses that memory",
"      location on the stack for, and will most likely have nothing to do with",
"      the original variable.",
"",
"",
"10.  Globals Window",
"",
"The Globals window is a Frame window that evaluates C expressions in the global",
"name space of a process.  Its menu bar contains a menu that lists all the global",
"variables.",
"",
"Unlike Frame windows, which are automatically closed when their activation",
"records are no longer on the stack, the Globals window exists for the lifetime",
"of a process and may be used before the first instruction is executed.  This",
"feature may be used to alter data in the data segment of a process before it",
"starts.",
"",
"10.1  Globals Layout",
"",
"The title bar identifies the window and displays the process id number or name",
"of the core file.  The lines within the window are in the same format as lines",
"found in Frame windows.",
"",
"10.2  Globals Menu Bar",
"",
" spies    Re-evaluate and redisplay all the spy expressions in the window.  This",
"          is equivalent to the \"changed spies\" entry in a Frame window's \"frame\"",
"          menu.  This button is not present when a core dump is examined.",
"",
"The \"vars\" menu contains the following entries:",
"",
" all           Display all of the global variables.  This is equivalent to",
"               selecting all the other entries in the \"vars\" menu.",
"",
" variable Glb  A menu entry in this format appears for each global variable in",
"               the symbol table.  Selecting a variable's entry causes that",
"               variable to be displayed on a new line in the window.  These",
"               entries are equivalent to the \"variable storage_class\" entries in",
"               a Frame window's menu, except the storage class field is always",
"               Glb.  The entries are alphabetically sorted in the menu.",
"",
"The \"regs\" menu contains the following entries:",
"",
" all      Display all of the registers.  This is equivalent to selecting all the",
"          other entries in the \"regs\" menu.",
"",
" $regname As in Frame windows, there will be an entry in this format for each",
"          processor register.  The register names depend on the machine's",
"          architecture and can be found in the \"Processor Dependencies\" section.",
"          Selecting an entry displays the current value of that register, and is",
"          equivalent to selecting it in the Frame window for the most recent",
"          activation record on the stack.",
"",
"Global variables from files without the -g option make it into the \"vars\" menu,",
"but they usually have incorrect type information.  The symbol table will claim",
"their type is int or long, even if they are not.  If you know a variable's",
"correct type you can use the casting operators (see \"Casting\") to force pi to",
"override the type information extracted from the symbol table.",
"",
"10.3  Globals Line Menus",
"",
"Lines in the Globals window generates the same menus and accepts the same",
"keyboard expressions as Frame windows, except the search for identifiers starts",
"in the global name space.  See \"Frame Lines\".",
"",
"",
"11.  Memory Window",
"",
"This window allows memory to be examined and edited as a sequence of 1-, 2-, 4-,",
"or 8-byte cells.  With the line menus a cell's size and formatting options may",
"be changed or the cells near a displayed cell may be opened.  The keyboard",
"language allows you to open a new cell at an arbitrary address, assign the value",
"of a C expression to a cell, or search through the cells for a specified value.",
"The Memory window is opened from the \"views\" menu in the Process window, or the",
"line menus in a Frame or Assembler window.",
"",
"While Frame windows are usually used to examine data, the Memory window provides",
"an alternative, unstructured view of memory and is most useful when no symbol",
"table entries are available.  It is often easier to change the cell size and",
"formatting options from the Memory window than to perform a series of casts in a",
"Frame window.  The Memory window also allows you to determine how machine",
"instructions or bit fields in structures are encoded.",
"",
"11.1  Memory Layout",
"",
"The title bar identifies the window type and displays the process id number or",
"name of the core file.  All lines within a Memory window display the address and",
"value of a memory cell, and have the format:",
"",
"     address/size: value",
"",
"The formats of the address and value fields depend on the formatting options",
"that have been selected from the cell's line menu.  If multiple formatting",
"options have been turned on the address and value fields are displayed several",
"times and the character `=' is used as a separator.  The address field supports",
"the same symbolic and numeric formats used to display addresses in the Assembler",
"window (see \"Assembler Layout\").  The size is either 1, 2, 4, or 8 bytes.",
"",
"Lines that start with the special character sequence \">>>\" are spies, and will",
"update their displayed values automatically.  On other lines, the displayed",
"value is the value of the cell when it was created in the window, or the last",
"time a formatting or size option was changed for the cell.",
"",
"The lines within the Memory window are sorted by address.  Creating a new cell",
"with the same address as a previous entry in the window overwrites the previous",
"entry.",
"",
"11.2  Memory Keyboard",
"",
"Syntax",
"",
"      . = expression",
"",
"The window's keyboard language accepts the address of a new memory cell.  When a",
"line in this syntax is entered, the expression is evaluated and the memory cell",
"at the resulting address is displayed.  The format and size options for the new",
"cell are inherited from the last cell evaluated in the window.",
"",
"The expression may be constructed from global identifiers, integer constants (C",
"character, integer, and explicit long constants), and the following C operators,",
"listed in order of decreasing precedence:",
"",
"     Operator        Associativity",
"     --------        -------------",
"     () []           left to right",
"     - &             right to left",
"     * / %           left to right",
"     + -             left to right",
"",
"This restricted set of expressions is the same set accepted by the Assembler",
"window.  For example, to display the memory at the hexadecimal address 0x2020,",
"type:",
"",
"      .=0x2020",
"",
"while to see the encoding of the first instruction mplementing the function",
"main() type:",
"",
"      .=&main",
"",
"11.3  Memory Line Menus",
"",
" spy on   Spy on the selected memory cell.  After selecting this entry, the",
"          characters \">>>\" are inserted at the beginning of the line to indicate",
"          the cell will be reevaluated and displayed automatically, as described",
"          in \"Spies\".  This menu entry is not present when examining core dumps",
"          or if the current expression is already a spy.",
"",
" unspy    Turn off spying for the selected memory cell.  This menu entry only",
"          appears if the cell is a spy.",
"",
" size     Change the size of the memory cell to the selected size, and then",
"          reevaluate and display it.  The cell is reevaluated even if the new",
"          cell size is the same as the old, providing a way to update the cell",
"          even though there is no explicit evaluation entry in the menu.  When",
"          the window is first opened the default cell size is 1 byte.",
"",
" format   This sub-menu controls the format used to display the address and",
"          value of the selected memory cell.  Choosing a formatting entry",
"          reevaluates the cell and displays it with the newly selected format.",
"",
" next     Thhis sub-menu opens and displays from 1 to 100 of the memory cells",
"          that follow the selected cell.  The format and size options for the",
"          new cells are inherited from the selected cell.",
"",
" prev     Just like \"next\", except the memory cells before the selected cell are",
"          displayed.",
"",
" * thru . Treat the selected memory cell's value as an address, and open the",
"          memory cell at that location.  This entry is useful for dereferencing",
"          cells that contain pointers.  The format and size options for the new",
"          cell are inherited from the selected line.  This entry is not in the",
"          menu if the cell size is 8 bytes.",
"",
" asmblr   Open the Assembler window and disassemble the instruction starting at",
"          the address of the memory cell.  If the cell's address is not on an",
"          instruction boundary, the instruction printed in the Assembler window",
"          will be incorrect.",
"",
"The options in the \"format\" menu depends on the cell's size.  Some formatting",
"options apply to both the address and value fields of the cell, while others",
"apply only to the value or only to the address.  The formatting entries allow",
"the current setting to be toggled:",
"",
" unsd_dec on|off  Display the address and value as unsigned decimal numbers.",
"",
" sign_dec on|off  Display the address and value as signed decimal numbers.",
"",
" octal on|off     Display the address and value as octal numbers.",
"",
" hex on|off       Display the address and value as hexadecimal numbers.",
"",
" ascii on|off     Display the value as a sequence of ASCII characters.  The",
"                  number of characters displayed depends on the cell size.",
"",
" symbolic on|off  Display the address symbolically.",
"",
" time on|off      Treat the value as a Unix representation of time (the number",
"                  of seconds since the epoch 00:00:00 GMT, January 1, 1970), and",
"                  display it as an ASCII date and time.  This entry is only",
"                  generated if the cell size is 4 bytes.",
"",
" float on|off     Display the value as a float using up to 6 decimal places.",
"                  This entry is only generated if the cell size is 4 bytes.",
"",
" double on|off    Display the value as a double using up to 15 decimal places.",
"                  This entry is only generated if the cell size is 8 bytes.",
"",
"11.4  Memory Line Keyboard",
"",
"Syntax",
"",
"      . = expression",
"      $ = expression",
"      <CR>",
"      /[string]",
"      ?string",
"",
"The keyboard language for a line allows you to enter the address of a new memory",
"cell, change the value of a memory cell, display the next cell, or search",
"forwards and backwards though cells for a string.  The format",
"",
"      . = expression",
"",
"opens a new memory cell at the address given by the expression, and behaves like",
"the window's keyboard language.  The format",
"",
"     $ = expression",
"",
"evaluates the expression, assigns its value to the currently selected memory",
"cell, and then revaluates and displays the cell.  The C expression has the same",
"restrictions as expressions used in the window's keyboard language.  It may be",
"constructed from global identifiers, integer constants, and the C operators",
"described in the \"Memory Keyboard\" section.",
"",
"Since the keyboard language's expression grammar does not support floating point",
"constants, it is not possible to assign floating constants to 4-byte cells or",
"double constants to 8-byte cells.  Because C does not support 8 byte integer",
"constants, all assignments to 8-byte cells fail.  If you need to assign a value",
"to a 8-byte cell, break it into 2 4-byte cells and assign values to the two",
"halves.",
"",
"A blank line, entered by typing just a carriage return, displays the next cell",
"and is equivalent t selecting \"next 1\" in the cell's line menu.",
"",
"The last two keyboard formats:",
"",
"     /[string]",
"     ?string",
"",
"allow you to search forwards (backwards) through cells for the given string.",
"Starting at the first cell after (before) the selected cell, pi evaluates the",
"cell and formats the line into an internal buffer, but does not display it in",
"the window.  The cell size and formatting options are inherited from the",
"selected cell.  A search is then made to see if the string is embedded anywhere",
"in the internal buffer.  The string must match exactly and is not a regular",
"expression.  If a match is found, the search stops and the cell containing the",
"match is displayed and selected.  If no match is found, the search continues",
"with the next (previous) memory cell.  Once a search is started, it continues",
"until either:",
"",
"  1.  An exact match with the string is found.",
"",
"  2.  An error occurs attempting to read a cell's memory.  This usually happens",
"      when the search reaches a segment boundary, such as the end of the data",
"      segment.",
"",
"  3.  10 seconds has elapsed and neither of the first two conditions is true.",
"",
"Because the string comparison is made with the formatted internal buffer for",
"each cell, and not directly with the cell's memory, what a string matches will",
"depend on the formatting options and cell size of the selected line.  For",
"example, if you have a big array of floating point numbers and you know one has",
"the value 3.14, you can search for that value with the following sequence:",
"",
"  1.  Open the memory cell for the first element of the array from the \"mem .=$\"",
"      menu entry in a Frame window or using the \".=expression\" keyboard syntax",
"      in the Memory window.",
"",
"  2.  Set the cell size to 4 bytes from the \"size\" menu.",
"  3.  Use the \"format\" menu to select \"float on\".",
"",
"  4.  Enter \"/3.14\" from the keyboard.",
"",
"Similarly, you can search for numbers in octal, hex, signed or unsigned decimal,",
"or ASCII characters.  The internal buffer the comparison is made with contains",
"an exact copy of what the window would display for that cell, including the",
"address field, so the string may match characters in the address.  For example,",
"if the selected line displays:",
"",
"     0xEFFFC00/4: 0xEDF4157",
"",
"and you want to look at the entry that starts 0x20 bytes after this entry, you",
"may type:",
"",
"     /20/",
"",
"to search for it instead of typing in the whole address.  The closing `/'",
"matches the `/' after the address field, since that is the only `/' character",
"that will appear in lines that have the hexadecimal formatting option on.",
"",
"If the optional string is not present, the string used in the last search is",
"used again.  The string is required with `?' because if the input line consists",
"of the single character `?', pi's help mechanism is invoked.",
"",
"",
"12.  User Types Window",
"",
"The User Types window displays the declarations of structs and unions. For each",
"type of struct or union defined in a program, pi maintains a template that",
"describes how an instance of that type is displayed.  The template consists of:",
"",
"  1.  A list of members that should be displayed.",
"",
"  2.  The formatting options that should be used to display each member.",
"",
"In addition to the type's declaration, the User Types window displays the",
"current template settings.  From the menus, you may add and remove members from",
"the template's list of members to display and for each member, you may set the",
"formatting options.  The window does not accept keyboard input.",
"",
"In many debugging sessions, the User Types window is never opened.  Members of",
"structs and unions may be added implicitly to a template's display list by",
"asking to display that member in a Frame window.  Similarly, setting the",
"formatting options for a structure or union member in a Frame window",
"automatically changes them in the template.  However, only the User Types window",
"may be used to remove members from the display list of a struct or union's",
"template.",
"",
"12.1  User Types Layout",
"",
"The title bar identifies the window type and displays the process id number or",
"name of the core file.  The lines within the window display the declarations for",
"structs and unions.  Lines displaying members are in the format:",
"",
"     [>>>]   type    member_name;    format_options",
"",
"The optional \">>>\" characters at the beginning of a line, if present, indicate",
"the member is in the template's list of displayed members.  By default, the",
"initial list contains the first two members in the structure declaration.  The",
"type field displays the data type of that member.",
"",
"The format_options field displays the current formatting options.  If the member",
"is another struct or union, the format_options field is empty, and the format",
"used to display it is inherited from the template for that type.",
"",
"Examining a struct and union type for the first time in a Frame window displays",
"that type in the User Types window automatically, if it is open.  Also, asking",
"to see or changing the format of a struct or union member from a Frame window",
"automatically updates that member's line in the User Types window.",
"",
"12.2  User Types Menu Bar",
"",
"The \"structs\" menu contains an entry listing the tag name for every struct or",
"union type defined in the program's symbol table.  Selecting an entry displays",
"the declaration for that type and selects the first line in the declaration.",
"",
"12.3  User Types Line Menus",
"",
"If the line displays a member of a struct or union that is not another struct or",
"union, the line menu contains the following entries:",
"",
" show    Add the member to the struct or union's list of members to display.",
"         This entry is only available on lines that do not start with \">>>\".",
"",
" hide    Remove the member from the struct or union's list of members to",
"         display.  This entry is only available on lines that start with \">>>\".",
"",
" format  This menu allows you to change the formatting options used to display",
"         the member.  The menu depends on the members type, as described in",
"         \"Format Menus\".  Selecting an entry in the format menu of a member that",
"         is not in the display list automatically adds it to the list.",
"",
"If the member on a line is a struct or union, the \"format\" entry is replaced",
"with an entry of the form:",
"",
" struct|union tag_name",
"         Choosing these entries displays the declaration for that structure in",
"         the window and then selects the first line of the structure's",
"         declaration.  This way, structures that have other structures embedded",
"         in them can be browsed through easily.",
"",
"The first and last line of a struct or union's declaration in the window, i.e.",
"lines of the form:",
"",
"     struct|union tag_name {",
"     } struct|union tag_name",
"",
"generate menus that allow all the members to be added to or removed from the",
"template's display list with a single menu selection:",
"",
" show all Add all members of the struct or union to the template's display list.",
"          This is equivalent to selecting \"show\" for each member.",
"",
" hide all Remove all members of the struct or union from the template's display",
"          list.  This is equivalent to selecting \"hide\" for each member.",
"",
"",
"13.  Breakpoint Window",
"",
"This window displays a program's breakpoints.  This includes breakpoints,",
"conditional breakpoints, and tracepoints that have been set in Assembler and",
"Source Text windows.  The menu bar allows all the breakpoints to be removed with",
"a single menu selection.  The line menu for each breakpoint allows the",
"breakpoint to be removed, or the source statement or machine instruction where",
"the breakpoint was set to be selected.  The window can be opened from the",
"\"Breakpoints\" entry in the Process window's \"views\" menu, and is opened",
"automatically if an error occurs while attempting to set a breakpoint in a",
"program.  The window cannot be created when core dumps are examined.",
"",
"Since breakpoints may be removed with the \"clr bpt\" entry in the line menus of",
"Assembler and Source Text windows, the Breakpoint window is used infrequently.",
"However, the window provides the most efficient way to remove a large number of",
"breakpoints and is useful if you can't remember where the breakpoints were",
"placed.",
"",
"The format used to display breakpoints in the Breakpoint window is compatible",
"the Process window's keyboard language, allowing the breakpoints to be saved",
"into a file and read back in later.  This feature may be used to copy a",
"complicated set of breakpoints between two different instances of the same",
"program.  See \"Process Keyboard\".",
"",
"13.1  Breakpoint Layout",
"",
"The title bar identifies the window and lists the process id number.  Each line",
"displays a breakpoint, tracepoint or conditional breakpoint, and is in one of",
"two formats:",
"",
"     file:linenumber [condition]",
"     pc=address",
"",
"The \"file:lineumber\" format is used for breakpoints set in Source Text windows.",
"With conditional breakpoints, the condition is the expression evaluated each",
"time the breakpoint is hit.  For tracepoints the condition is 0.  Breakpoints",
"set in the Assembler window use the \"pc=address\" format and display the",
"instruction address as a decimal number.  The breakpoints are listed in the",
"order they were set.",
"",
"13.2  Breakpoint Menu Bar",
"",
"The \"bpts\" menu has the following entries:",
"",
" clear all   Remove all breakpoints from the process.  A pop-up window will ask",
"             you to confirm this choice before it is executed.",
"",
" clean list  Redisplay the lines in the window.  This is only needed if an error",
"             occurred while trying to set a breakpoint.  For example, if you set",
"             a breakpoint at a statement in a Source Text window, and then",
"             disassemble the statement and try to set a breakpoint at the",
"             statement's first instruction from the Assembler window, an error",
"             occurs because you are attempting to set two different breakpoints",
"             at the same instruction.  If this happens, the line displaying the",
"             original breakpoint changes to an error message such as:",
"",
"                  test1.c:20 same location as pc=8982",
"",
"             and \"clean list\" removes the error message.",
"",
"13.3  Breakpoint Line Menus",
"",
" clear bpt  Remove the breakpoint.  If the Source Text or Assembler window that",
"            contains the line where the breakpoint was set is open, that window",
"            and line are selected after the breakpoint is removed.",
"",
" src text   Open the Source Text window and select the statement at the location",
"            of the breakpoint. This entry is present if the breakpoint was set",
"            from the Assembler window, i.e. lines in the window that are in the",
"            format \"pc=address\".",
"",
" assembler  Open the Assembler window and disassemble the instruction at the",
"            location of the breakpoint.  If the process is stopped, the original",
"            statement is displayed.  If the process is running, the instruction",
"            implementing the breakpoint is displayed.",
"",
"",
"14.  Signals Window",
"",
"This window controls the delivery of Unix signals to the process.  From the",
"window signals can be sent to the process or signals sent from other sources may",
"be intercepted.  The window cannot be opened for core dumps.",
"",
"When a signal is sent to a process that is running under the control of a",
"debugger, the Unix operating system gives the debugger the opportunity to",
"intercept and cancel the signal before the target process receives it.  The",
"Signals window allows you modify the set of signals that are intercepted and",
"traced by the debugger.  Signals that are not in the traced set, bypass the",
"debugger and are sent directly to the target process.",
"",
"When pi intercepts a signal that is being traced for a process, the process is",
"suspended and a message of the form:",
"",
"     EVENT PENDING: signal name",
"",
"is placed on the status line of the Process window.  At this point you have the",
"option to either send the signal to the process or cancel it.  To cancel it, use",
"the \"clear pending signal\" entry in the Signals window's menu bar.  To send the",
"signal, just continue the execution of the process.",
"",
"14.1  Signals Layout",
"",
"The title bar lists the process id number.  Lines within the window display",
"signal names and are ordered by signal number.  Signals that are being traced",
"start with the characters \">>>\".",
"",
"By default, the following signals are traced: SIGINT, SIGILL, SIGTRAP, SIGIOT,",
"SIGEMT, SIGFPE, SIGBUS, SIGSEGV, SIGSYS, SIGPIPE, and SIGSTOP.  SIGTRAP and",
"SIGSTOP are used by the debugger and must be traced for pi to operate correctly.",
"It is impossible to trace SIGKILL, as the operating system does not allow this",
"signal to be intercepted by the debugger and it always kills the process.",
"",
"If the operating systems supports a debugging primitive that suspends an exec()",
"system call before the first instruction of the new program is executed, the",
"Signals window allows you to toggle this option.  This stop-on-exec feature is",
"supported in pi with versions of the Unix operating system that have mounted",
"processes, and in rtpi with targets running NRTX.  When present, the bottom line",
"in the window displays \">>> exec()\" when the option is configured to stop the",
"process if it calls exec(), and \"exec()\" if it is configured to execute the",
"exec() at full speed.  The line's menu toggles the setting.",
"",
"14.2  Signals Menu Bar",
"",
"The \"signals\" menu contains the following entries:",
"",
" clear pending signal",
"   Clear the signal that is pending for the process.  This entry should be used",
"   when the status line in the Process window displays a line of the form:",
"",
"        EVENT PENDING: signal name",
"",
"   and you don't want the signal to be sent to the process when it is resumed.",
"",
" clear pending signal and go",
"   Clear the signal that is pending for the process and start it executing.",
"   This is equivalent to selecting \"clear pending signal\" and then \"run\" in the",
"   Process window's \"stmt\" menu.",
"",
"14.3  Signals Line Menus",
"",
" trace on|off Toggle tracing of the signal.  If the line starts with the",
"              character sequence \">>>\" the signal is currently being traced and",
"              the menu entry lets you turn tracing off.  Otherwise the signal is",
"              not being traced and the entry lets you turn tracing on.",
"",
" send signal  Send the selected signal to the process.",
"",
"If the operating system supports the stop-on-exec option the bottom line in the",
"window is:",
"",
"     [>>>] exec()",
"",
"and its line menu contains one of the following:",
"",
" hang   Set the stop-on-exec flag so if the process calls the exec() system",
"        call, it stops before the first instruction in the new program is",
"        executed.",
"",
" clear  Set the stop-on-exec flag so if the process calls the exec() system",
"        call, the new program executes at full speed.",
"",
"",
"15.  Journal Window",
"",
"This window, if opened, keeps a log of the following events for a process:",
"",
"  1.  A copy of the status line and the line for the most recent activation",
"      record in the Process window, every time they are updated.",
"",
"  2.  The selection of any menu operators that cause that process to execute,",
"      step, or stop.",
"",
"  3.  Every time a conditional breakpoint or tracepoint is hit, a copy of the",
"      updated source statement from the Source Text window.",
"",
"  4.  Any spy expressions that change values.",
"",
"The window does not generate menus or accept keyboard input, and cannot be",
"opened for core dumps.",
"",
"15.1  Journal Layout",
"",
"The title bar lists the process id number and the window displays logged",
"information.  For example, part of a typical log is shown below:",
"",
"     run",
"     RUNNING:  pc=test1.c:21",
"     test1.c:21 [5] i=3, j=16, i==5=0 a()   j += b(i);",
"     test1.c:21 [6] i=4, j=22, i==5=0 a()   j += b(i);",
"     test1.c:21 [7] i=5, j=29, i==5=1 a()   j += b(i);",
"     BREAKPOINT:",
"     test1.c:21 a(i=5,j=29)",
"",
"The \"run\" line was  inserted into the window by selecting \"run\" in the \"stmt\"",
"menu.  The \"RUNNING\" line is a copy of the updated status line in the Process",
"window.  The next three lines are hits to the conditional breakpoint \"i, j,",
"i==5\" on line 21 in the file test1.c.  When the value of i was 5 the breakpoint",
"condition was true, causing the process to stop.  The last two lines are copies",
"of the updated status line and top activation record in the Process window.",
"",
"If a line entered into the Journal window is identical to the previous line,",
"rather than repeating the same line multiple times a count in parenthesis is",
"appended to the previous line to indicate it occurs again.  This is likely when",
"the process is blocked in a system call, such as read, causing the same status",
"line from the Process window to be inserted into the Journal window once a",
"second until the call returns.",
"",
"The Journal window is most useful when used with conditional breakpoints to",
"trace the values of C variables or expressions.  For example, to keep a record",
"of the values of the arguments passed to a function each time it is called:",
"",
"  1.  Display the function in the Source Text window.",
"",
"  2.  Select the statement where you want to evaluate the arguments.",
"",
"  3.  In the statement's line menu, select the \"cond bpt\" entry and for each",
"      argument you want to trace, type in its name followed by a comma, and end",
"      the line with a 0. For example, to trace arguments arg1 and arg2 enter:",
"",
"           arg1, arg2, 0",
"",
"      This conditional breakpoint displays the values of arg1 and arg2 each time",
"      it is hit, but never stops the process.",
"",
"  4.  Open the Journal window from the \"Journal\" entry in the Process window's",
"      \"views\" menu.",
"",
"  5.  Start the process executing with \"run\" in the \"stmt\" menu.",
"",
"Every time the function is entered, the conditional breakpoint will be hit and",
"evaluated, causing the values of the arguments to be entered into the Journal",
"window.  Since the format used to display the values of variables in condition",
"breakpoints is inherited from their Frame window settings, you may use a Frame",
"window to control how traced variables are displayed in the Journal.",
"",
"The Journal window is currently limited to 200 lines.  When the window reaches",
"its maximum length, new lines added to the window delete the lines at the",
"beginning.",
"",
"",
"16.  Directory Window",
"",
"This window displays and changes the working directory of the debugger.  The",
"working directory determines where the debugger looks when trying to open files",
"that have relative path names.  It affects where executable files containing the",
"symbol tables, core dumps, and source code files for processes that have not",
"specified a directory search path in their Source Files window are found.  The",
"window is opened by selecting the \"pwd/cd\" entry in the Keyboard Input window's",
"\"windows\" menu.",
"",
"16.1  Directory Layout",
"",
"Each line in the Directory window displays the full path name of a directory,",
"and is the output of the command \"/bin/pwd\".  The last line in the window starts",
"with the characters \"wd=\" and displays the debugger's current working directory.",
"When the working directory is changed from the keyboard or menus, a line listing",
"the new working directory is appended after the last line in the window, and the",
"previous working directory becomes the next to last line.  The window keeps an",
"ordered history of the directories that have been visited.",
"",
"If an error occurs while attempting to change directories the message:",
"",
"     cannot cd directory",
"",
"is inserted into the window.",
"",
"16.2  Directory Menu Bar",
"",
"The \"chdir\" menu is the line menu for the line displaying the working directory.",
"See \"Directory Line Menus\".",
"",
"16.3  Directory Keyboard",
"",
"Syntax",
"",
"      [cd] [directory]",
"",
"The window's keyboard language allows you to change the working directory of the",
"debugger by typing in a new directory name.  The directory may be a full path",
"name, or a path name relative to the current directory.  The optional \"cd\" is",
"provided for compatibility with the command used to change directories in most",
"shells.  If the directory field is missing, the debugger changes to the",
"directory in the environment variable HOME.",
"",
"16.4  Directory Line Menus",
"",
"Each line menu lists the subdirectories of the directory displayed on the line.",
"Selecting an entry makes that directory the working directory.  Each menu also",
"has \".\" and \"..\" entries to allow you to move to to the directory displayed on",
"the line or its parent directory.",
"",
"",
"17.  Help Window",
"",
"This window describes how to to use the debugger and may be opened several ways.",
"",
"  1.  Select entries in the \"help\" sub-menus that are available at the bottom of",
"      every window's \"edit\" menu.  These open the Help window and display the",
"      sections that describe the window.",
"",
"  2.  Type \"?\" in any window.  This opens the window and scrolls to the",
"      description of the selected line or window's keyboard language.",
"",
"  3.  Select \"help\" in the Unix pi window's menu bar.  In Rtpi, the \"help\"",
"      button is in the Rtpi window.",
"",
"  4.  Select \"help\" in the Keyboard Input window's \"windows\" menu.",
"",
"17.1  Help Menu Bar",
"",
"The \"topics\" menu lists of topics that are discussed in the Help window.",
"Selecting a topic scrolls the window to that topic.",
"",
"",
"18.  Processor Dependencies",
"",
"This section describes the processor dependencies such as register names.  There",
"is a separate section for each processor.",
"",
"18.1  SPARC",
"",
"The SPARC architecture is used in Sun's SPARCstations and Sun4 family of",
"workstations and is supported in SPARC pi.  The registers are named:",
"",
"     $g0-$g7, $o0-$o5, $sp, $o7, $l0-$l7, $i0-$i5, $fp, $i7, $psr, $pc, $npc,",
"     and $y.",
"",
"The values of $o0-$o5, $sp, $o7, $l0-$l7, $i0-$i5, $fp, and $i7 are extracted",
"from their saved locations on the stack and vary in different Frame windows.",
"The other registers display the same value in all Frame windows.  The value of",
"$g0 is always 0.",
"",
"18.2  MIPS R3000",
"",
"The MIPS Computer Systems R3000 and R4000 processors are used in Silicon",
"Graphics (SGI) workstations and are supported in SGI pi.  The register names use",
"the MIPS software conventions:",
"",
"     $zero, $at, $v0, $v1, $a0-$a3, $t0-$t7, $s0-$s7, $t8, $t9, $k0, $k1, $gp,",
"     $sp, $s8, $ra, $pc, $cause, $badvaddr, $mmhi, $mmlo, $fpcpcsr, and $fpceir.",
"",
"The values of $s0-$s7 and $ra are extracted from their saved locations on the",
"stack and vary in different Frame windows.  The other registers display the same",
"value in all Frame windows.  The value of $zero is always 0.",
"",
"18.3  MC680X0",
"",
"Members of the Motorola MC680X0 family of processors are supported in Sun-3 pi.",
"The registers are named:",
"",
"     $d0-$d7, $a0-$a5, $fp, $sp, $ps and $pc.",
"",
"The values of $d2-$d7 and $a2-$a5 are extracted from their saved locations on",
"the stack and vary in different Frame windows.  The other registers display the",
"same value in all Frame windows.",
"",
"18.4  PCs",
"",
"The PC version of pi and rtpi's Remote Unix Pi window support 80[34]86 based",
"personal computers running Unix SysV R3.2.[23].  The registers are named:",
"",
"     $eax, $ecx, $edx, $ebx, $esp, $ebp, $esi, $edi, $eip, $eflags, $ds, $es,",
"     $fs, $gs, $ss, $cs, $trapno, $error, and $kesp.",
"",
"The values of $ebx, $esi, and $edi are extracted from their saved locations on",
"the stack and vary in different Frame windows.  The other registers display the",
"same value in all Frame windows.",
"",
"",
"19.  Bugs",
"",
"Known bugs are listed below.  If you discover a new one, please report it to",
"research!dak or dak@research.att.com.",
"",
"On some types of processors if a program is suspended in the middle of a",
"function's prologue the values of arguments in the Process window's top",
"activation record are displayed incorrectly.  Pi determines the number of",
"activation records by following the frame pointers, and if a process is stopped",
"in a prologue before the frame pointer is updated, the new activation record may",
"use the wrong frame pointer.  This can happen if the process is stopped",
"asynchronously with \"stop\", or a function is stepped into from the Assembler",
"window.  Stepping a few more instructions from the Assembler window remedies the",
"problem.",
"",
"19.1  Bugs in SunOS 4.X",
"",
"These bugs occur with SunOS releases 4.X.  They are caused by problems with the",
"ptrace system call that is available for debugging.  The bugs are not present in",
"SunOS releases 5.0 (Solaris 2.0) and later, as mounted processes are used for",
"debugging.",
"",
"The \"open child\" line menu entry in the Unix Pi window is not very useful.  When",
"a process controlled by pi calls fork(), the child process inherits the parent's",
"breakpoints.  Under SunOS 4.X, if the child hits any of these breakpoints before",
"pi attaches to it, the SIGTRAP signal generated kills the process, instead of",
"suspending it.",
"",
"A parent process waiting for a child process to finish with wait() blocks",
"indefinitely if pi is examing the child process when the child exits or dies.  A",
"bug in the operating system causes the debugger to receive the information",
"returned by wait() instead of the parent.  This happens if you start a",
"foreground process in a shell, attach pi to it, and then the process dies.  A",
"solution is to start the program with hang.  While hang gets stuck in wait(),",
"the shell waits for hang, and not the process being debugged - so killing hang",
"forces the shell to returns from its call to wait().",
"",
"If pi examines a process while it is blocked in certain system calls the system",
"call returns -1 and errno is set to EINTR, behaving as if a signal was received",
"and serviced.  The operating system's implementation of ptrace() unblocks the",
"system call in the target process to service the debug request, and sometime",
"doesn't restart it.  While some system calls, such as read(), restart",
"automatically others, such as recv(), do not.  The only solution is to add code",
"to your program that checks if the system call returned -1 and errno==EINTR, and",
"if true, repeat the call.",
"",
"19.2  Bugs on Sparcs",
"",
"When function calls are evaluated in Frame windows, only 6 arguments or less may",
"be passed to the function.  Also, register arguments are passed incorrectly when",
"function calls are evaluated in Frame windows with code generated by Sun's",
"compiler.",
};

static int helplines = sizeof(helptext)/sizeof(char*);

static HelpTopicMap topicmap[] = {
	"Introduction\240", 1L,
	"Starting Pi\240", 26L,
	"Pads\240", 38L,
	"Remote Execution\240", 61L,
	"Stack Trace\240", 94L,
	"Compiling\240", 107L,
	"C++ Code\240", 120L,
	"Distribution\240", 148L,
	"OPENLOOK Interface\240", 171L,
	"Mouse Buttons\240", 202L,
	"Window Manager\240", 220L,
	"Window Layout\240", 239L,
	"Menu Bars\240", 245L,
	"Edit Menu\240", 281L,
	"Line Menus\240", 314L,
	"Keyboard Input Window\240", 332L,
	"X Resources\240", 395L,
	"Window Types\240", 435L,
	"Help Conventions\240", 531L,
	"Definitions\240", 561L,
	"Unix Pi Window\240", 638L,
	"Unix Pi Layout\240", 683L,
	"Unix Pi Menu Bar\240", 721L,
	"Unix Pi Keyboard\240", 751L,
	"Unix Pi Line Menus\240", 807L,
	"Process Window\240", 887L,
	"Process Layout\240", 895L,
	"Process Menu Bar\240", 991L,
	"Process Keyboard\240", 1140L,
	"Process Line Menus\240", 1209L,
	"Source Files Window\240", 1230L,
	"Source Files Layout\240", 1243L,
	"Source Files Menu Bar\240", 1300L,
	"Source Files Keyboard\240", 1330L,
	"Source Files Line Menus\240", 1353L,
	"Source Text Window\240", 1360L,
	"Source Text Layout\240", 1367L,
	"Source Text Opening Errors\240", 1457L,
	"Source Text Menu Bar\240", 1501L,
	"Source Text Keyboard\240", 1515L,
	"Source Text Line Menus\240", 1544L,
	"Source Text Line Keyboard\240", 1655L,
	"Assembler Window\240", 1687L,
	"Assembler Layout\240", 1696L,
	"Assembler Menu Bar\240", 1743L,
	"Assembler Keyboard\240", 1781L,
	"Assembler Line Menus\240", 1822L,
	"Frame Windows\240", 1917L,
	"Frame Layout\240", 1942L,
	"Frame Menu Bar\240", 1983L,
	"Frame Keyboard\240", 2125L,
	"Identifiers\240", 2186L,
	"Function Calls\240", 2233L,
	"Built-In Functions\240", 2258L,
	"Frame Lines\240", 2282L,
	"Basic Data Types\240", 2303L,
	"Format Menus\240", 2341L,
	"Casting\240", 2433L,
	"Arrays\240", 2551L,
	"Pointers\240", 2590L,
	"Structures and Unions\240", 2610L,
	"Enumerations\240", 2757L,
	"Non-Lvalue Expressions\240", 2780L,
	"Spies\240", 2799L,
	"Globals Window\240", 2883L,
	"Globals Layout\240", 2895L,
	"Globals Menu Bar\240", 2901L,
	"Globals Line Menus\240", 2937L,
	"Memory Window\240", 2944L,
	"Memory Layout\240", 2961L,
	"Memory Keyboard\240", 2985L,
	"Memory Line Menus\240", 3018L,
	"Memory Line Keyboard\240", 3086L,
	"User Types Window\240", 3184L,
	"User Types Layout\240", 3207L,
	"User Types Menu Bar\240", 3229L,
	"User Types Line Menus\240", 3235L,
	"Breakpoint Window\240", 3276L,
	"Breakpoint Layout\240", 3300L,
	"Breakpoint Menu Bar\240", 3316L,
	"Breakpoint Line Menus\240", 3336L,
	"Signals Window\240", 3353L,
	"Signals Layout\240", 3376L,
	"Signals Menu Bar\240", 3397L,
	"Signals Line Menus\240", 3414L,
	"Journal Window\240", 3438L,
	"Journal Layout\240", 3456L,
	"Directory Window\240", 3516L,
	"Directory Layout\240", 3526L,
	"Directory Menu Bar\240", 3542L,
	"Directory Keyboard\240", 3547L,
	"Directory Line Menus\240", 3560L,
	"Help Window\240", 3568L,
	"Help Menu Bar\240", 3584L,
	"Processor Dependencies\240", 3590L,
	"SPARC\240", 3595L,
	"MIPS R3000\240", 3608L,
	"MC680X0\240", 3621L,
	"PCs\240", 3632L,
	"Bugs\240", 3645L,
	"Bugs in SunOS 4.X\240", 3660L,
	"Bugs on Sparcs\240", 3691L,
};

static int ntopics = sizeof(topicmap)/sizeof(HelpTopicMap);
